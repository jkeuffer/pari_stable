% $Id$
% Copyright (c) 2000  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{Technical Reference Guide for Low-Level Functions}

In this chapter, we describe all public low-level functions of the
PARI library. These essentially include functions for handling all the PARI
types. Higher level functions, such as arithmetic or transcendental
functions, are described in Chapter~3 of the GP user's manual. A general
introduction to the major concepts of PARI programming can be found in
Chapter~4.

Many other undocumented functions can be found throughout the source code.
These private functions are more efficient than the library wrappers, but
sloppier on argument checking and damage control. Use them at your own risk!

\misctitle{Important advice}: generic routines eventually call lower level
functions. Optimize your algorithms first, not overhead and conversion costs
between PARI routines. For generic operations, use generic routines first,
don't waste time looking for the most specialized one available unless you
identify a genuine bottleneck. The PARI source code is part of the
documentation; look for inspiration there.\smallskip

We let \B\ abbreviate \tet{BITS_IN_LONG}. The type \kbd{long} denotes a
\B-bit signed long integer. The type \tet{ulong} is defined as \kbd{unsigned
long}. The word \emph{stack} always refer to the PARI stack, allocated
through an initial \kbd{pari\_init} call. Refer to Chapters 1--2 and~4 for
general background. \kbdsidx{BIL}

We shall often refer to the notion of \tev{shallow} function, which means that
some components of the result may point to components of the input (which is
more efficient than a deep copy). Such outputs are not suitable for
\kbd{gerepileupto} and particular care must be taken when garbage collecting
objects which have been input to shallow functions: in general corresponding
outputs also become invalid and should no longer be accessed.

\section{Initializing the library}

The following functions enable you to start using the PARI functions
in a program, and cleanup without exiting the whole program.

\subsec{General purpose}

\fun{void}{pari_init}{size_t size, ulong maxprime} initialize the
library, with a stack of \kbd{size} bytes and a prime table
up to the maximum of \kbd{maxprime} and $2^{16}$. Unless otherwise
mentioned, no PARI function will function properly before such an
initialization.

\fun{void}{pari_close}{void} stop using the library (assuming it was
initialized with \kbd{pari\_init}) and frees all allocated objects.

\subsec{Technical functions}

\fun{void}{pari_init_opts}{size_t size, ulong maxprime, ulong opts} as
\kbd{pari\_init}, more flexible. \kbd{opts} is a mask of flags
among the following:

  \kbd{INIT\_JMPm}: install pari error handler. When an exception is
raised, the program is terminated with \kbd{exit(1)}.

  \kbd{INIT\_SIGm}: install pari signal handler.

  \kbd{INIT\_DFTm}: initialize the \kbd{GP\_DATA} environment structure.
This one \emph{must} be enabled once. If you close pari, then restart it,
you need not reinitialize \kbd{GP\_DATA}; if you do not, then old values are
restored.

\fun{void}{pari_close_opts}{ulong init_opts} as \kbd{pari\_close},
for a library initialized with a mask of options using
\kbd{pari\_init\_opts}. \kbd{opts} is a mask of flags among

  \kbd{INIT\_SIGm}: restore \kbd{SIG\_DFL} default action for signals
tampered with by pari signal handler.

  \kbd{INIT\_DFTm}: frees the \kbd{GP\_DATA} environment structure.

\fun{void}{pari_sig_init}{void (*f)(int)} install the signal handler \kbd{f}
(see \kbd{signal(2)}): the signals \kbd{SIGBUS}, \kbd{SIGFPE}, \kbd{SIGINT},
\kbd{SIGBREAK}, \kbd{SIGPIPE} and \kbd{SIGSEGV} are concerned.

\fun{void}{pari_stackcheck_init}{void *stackbase} controls the system stack
exhaustion checking code in the GP interpreter. This should be used when the
system stack base address change or when the address seen by \kbd{pari\_init}
is too far from the base address. If stackbase is \kbd{NUL}L, disable the
check, else set the base address to stackbase. It is normally used this way
\bprog
int thread_start (...)
{
  long first_item_on_the_stack;
  ...
  pari_stackcheck_init(&first_item_on_the_stack);
}
@eprog

\fun{int}{pari_daemon}{void} fork a PARI daemon, detaching from the main
process group. The function returns 1 in the parent, and 0 in the
forked son.

\subsec{Notions specific to the GP interpreter}

An \kbd{entree} is the generic object associated to an identifier (a name)
in GP's interpreter, be it a built-in or user function, or a variable. For
a function, it has at least the following fields:

  \kbd{char *name} : the name under which the interpreter knows us.

  \kbd{void *value} :  a pointer to the C function to call.

  \kbd{long menu} : an integer from 1 to 11 (to which group of function
                    help do we belong).

  \kbd{char *code} : the prototype code.

  \kbd{char *help} : the help text for the function.

A routine in GP is described to the analyzer by an \kbd{entree}
structure. Built-in pari routines are grouped in \emph{modules}, which
are arrays of \kbd{entree} structs, the last of which satisfy
\kbd{name = NULL} (sentinel).

There are currently six modules in GP: general functions
(\tet{functions_basic}), gp-specific functions (\tet{functions_fp}),
gp-specific highlevel functions (\tet{functions_highlevel}),
member functions, and two modules of obsolete functions. The function
\kbd{pari\_init} initializes the interpreter and declares all symbols
in \kbd{functions\_basic}. You may declare further functions on a case by
case basis or as a whole module using

\fun{void}{pari_add_function}{entree *ep} adds a single routine to the
table of symbols in the interpreter. It assumes \kbd{pari\_init} has been
called.

\fun{void}{pari_add_module}{entree *mod} adds all the routines in module
\kbd{mod} to the table of symbols in the interpreter. It assumes
\kbd{pari\_init} has been called.

\noindent For instance, gp implements a number of private routines, which
it adds to the default set via the call
\bprog
  pari_add_module(functions_gp);
  pari_add_module(functions_highlevel);
@eprog

\section{Handling \kbd{GEN}s}
\noindent Almost all these functions are either macros or inlined. Unless
mentioned otherwise, they do not evaluate their arguments twice. Most of them
are specific to a set of types, although no consistency checks are made:
e.g.~one may access the \kbd{sign} of a \typ{PADIC}, but the result is
meaningless.

\subsec{Length conversions}

\fun{long}{ndec2nlong}{long x} converts a number of decimal digits to a number
of words. Returns $ 1 + \kbd{floor}(x \times \B \log_2 10)$.

\fun{long}{ndec2prec}{long x} converts a number of decimal digits to a number
of codewords. This is equal to 2 + \kbd{ndec2nlong(x)}.

\fun{long}{prec2ndec}{long x} converts a number of of codewords to a
number of decimal digits.

\fun{long}{nbits2nlong}{long x} converts a number of bits to a number of
words. Returns the smallest word count containing $x$ bits, i.e $
\kbd{ceil}(x / \B)$.

\fun{long}{nbits2prec}{long x} converts a number of bits to a number of
codewords. This is equal to 2 + \kbd{nbits2nlong(x)}.

\fun{long}{nchar2nlong}{long x} converts a number of bytes to number of
words. Returns the smallest word count containing $x$ bytes, i.e
$\kbd{ceil}(x / \kbd{sizeof(long)})$.

\fun{long}{bit_accuracy}{long x} converts a \typ{REAL} length into a number
of significant bits. Returns $(x - 2)\B$. The macro
\tet{bit_accuracy_mul}$(x,y)$ computes the same thing multiplied by $y$.

\subsec{Read type-dependent information}

\fun{long}{typ}{GEN x} returns the type number of~\kbd{x}. The header files
included through \kbd{pari.h} define symbolic constants for the \kbd{GEN}
types: \typ{INT} etc. Never use their actual numerical values. E.g to determine
whether \kbd{x} is a \typ{INT}, simply check
\bprog
  if (typ(x) == t_INT) { }
@eprog\noindent
The types are internally ordered and this simplifies the implementation of
commutative binary operations (e.g addition, gcd). Avoid using the ordering
directly, as it may change in the future; use type grouping macros
instead (\secref{se:typegroup}).

\fun{long}{lg}{GEN x} returns the length of~\kbd{x} in \B-bit words.

\fun{long}{lgefint}{GEN x} returns the effective length of the \typ{INT} \kbd{x}
in \B-bit words.

\fun{long}{signe}{GEN x} returns the sign ($-1$, 0 or 1) of~\kbd{x}. Can be
used for \typ{INT}, \typ{REAL}, \typ{POL} and \typ{SER} (for the last two
types, only 0 or 1 are possible).

\fun{long}{gsigne}{GEN x} returns the sign of a real number $x$,
valid for \typ{INT}, \typ{REAL} as \kbd{signe}, but also for \typ{FRAC}.
Raise a type error if \kbd{typ(x)} is not among those three.

\fun{long}{expi}{GEN x} returns the binary exponent of the real number equal
to the \typ{INT}~\kbd{x}. This is a special case of \kbd{gexpo}.

\fun{long}{expo}{GEN x} returns the binary exponent of the
\typ{REAL}~\kbd{x}.

\fun{long}{gexpo}{GEN x} same as \kbd{expo}, but also valid when \kbd{x}
is not a \typ{REAL} (returns the largest exponent found among the components
of \kbd{x}). When \kbd{x} is an exact~0, this returns
\hbox{\kbd{-HIGHEXPOBIT}}, which is lower than any valid exponent.

\fun{long}{valp}{GEN x} returns the $p$-adic valuation (for
a \typ{PADIC}) or $X$-adic valuation (for a \typ{SER}, taken with respect to
the main variable) of~\kbd{x}.

\fun{long}{precp}{GEN x} returns the precision of the \typ{PADIC}~\kbd{x}.

\fun{long}{varn}{GEN x} returns the variable number of the
\typ{POL} or \typ{SER}~\kbd{x} (between 0 and \kbd{MAXVARN}).

\fun{long}{gvar}{GEN x} returns the main variable number when any variable
at all occurs in the composite object~\kbd{x} (the smallest variable number
which occurs), and \kbd{BIGINT} otherwise.

\fun{long}{degpol}{GEN x} returns the degree of \typ{POL}~\kbd{x},
\emph{assuming} its leading coefficient is non-zero (an exact $0$ is
impossible, but an inexact $0$ is allowed). By convention the degree of an
exact $0$ polynomial is $-1$. If the leading coefficient of \kbd{x} is $0$,
the result is undefined.

\fun{long}{lgpol}{GEN x} is equal to \kbd{degpol(x) + 1}. Used to loop over
the coefficients of a \typ{POL} in the following situation:
\bprog
    GEN xd = x + 2;
    long i, l = lgpol(x);
    for (i = 0; i < l; i++) foo( xd[i] ).
@eprog

\fun{long}{precision}{GEN x} If \kbd{x} is of type \typ{REAL}, returns the
precision of~\kbd{x}, namely the length of \kbd{x} in \B-bit words if \kbd{x}
is not zero, and a reasonable quantity obtained from the exponent of \kbd{x}
if \kbd{x} is numerically equal to zero. If \kbd{x} is of type
\typ{COMPLEX}, returns the minimum of the precisions of the real and
imaginary part. Otherwise, returns~0 (which stands for infinite precision).

\fun{long}{gprecision}{GEN x} as \kbd{precision} for scalars. Returns the
lowest precision encountered among the components otherwise.

\fun{long}{sizedigit}{GEN x} returns 0 if \kbd{x} is exactly~0. Otherwise,
returns \kbd{\key{gexpo}(x)} multiplied by $\log_{10}(2)$. This gives a crude
estimate for the maximal number of decimal digits of the components
of~\kbd{x}.

\subsec{Eval type-dependent information}.
These routines convert type-dependent information to bitmask to fill the
codewords of \kbd{GEN} objects (see \secref{se:impl}). E.g for a
\typ{REAL}~\kbd{z}:
\bprog
  z[1] = evalsigne(-1) | evalexpo(2)
@eprog
Compatible components of a codeword for a given type can be OR-ed as above.

\fun{ulong}{evaltyp}{long x} convert type~\kbd{x} to bitmask (first
codeword of all \kbd{GEN}s)

\fun{long}{evallg}{long x} convert length~\kbd{x} to bitmask (first
codeword of all \kbd{GEN}s). Raise overflow error if \kbd{x} is so large that
the corresponding length cannot be represented

\fun{long}{_evallg}{long x} as \kbd{evallg} \emph{without} the overflow
check.

\fun{ulong}{evalvarn}{long x} convert variable number~\kbd{x} to bitmask
(second codeword of \typ{POL} and \typ{SER})

\fun{long}{evalsigne}{long x} convert sign~\kbd{x} (in $-1,0,1$) to bitmask
(second codeword of \typ{INT}, \typ{REAL}, \typ{POL}, \typ{SER})

\fun{long}{evalprecp}{long x} convert $p$-adic ($X$-adic) precision~\kbd{x}
to bitmask (second codeword of \typ{PADIC}, \typ{SER})

\fun{long}{evalvalp}{long x} convert $p$-adic ($X$-adic) valuation~\kbd{x} to
bitmask (second codeword of \typ{PADIC}, \typ{SER}). Raise overflow error if
\kbd{x} is so large that the corresponding valuation cannot be represented

\fun{long}{_evalvalp}{long x} same as \kbd{evalvalp} \emph{without} the
overflow check.

\fun{long}{evalexpo}{long x} convert exponent~\kbd{x} to bitmask (second
codeword of \typ{REAL}). Raise overflow error if \kbd{x} is so
large that the corresponding exponent cannot be represented

\fun{long}{_evalexpo}{long x} same as \kbd{evalexpo} \emph{without} the
overflow check.

\fun{long}{evallgefint}{long x} convert effective length~\kbd{x} to bitmask
(second codeword \typ{INT}). This should be less or equal than the length
of the \typ{INT}, hence there is no overflow check for the effective length.

\subsec{Set type-dependent information}.
Use these macros with extreme care since usually the corresponding
information is set otherwise, and the components and further codeword fields
(which are left unchanged) may not be compatible with the new information.

\fun{void}{settyp}{GEN x, long s} sets the type number of~\kbd{x} to~\kbd{s}.

\fun{void}{setlg}{GEN x, long s} sets the length of~\kbd{x} to~\kbd{s}. This
is an efficient way of truncating vectors, matrices or polynomials.

\fun{void}{setlgefint}{GEN x, long s} sets the effective length
of the \typ{INT} \kbd{x} to~\kbd{s}. The number \kbd{s} must be less than or
equal to the length of~\kbd{x}.

\fun{void}{setsigne}{GEN x, long s} sets the sign of~\kbd{x} to~\kbd{s}.
If \kbd{x} is a \typ{INT} or \typ{REAL}, \kbd{s} must be equal to $-1$, 0
or~1, and if \kbd{x} is a \typ{POL} or \typ{SER}, \kbd{s} must be equal to 0
or~1.

\fun{void}{setexpo}{GEN x, long s} sets the binary exponent of the
\typ{REAL}~\kbd{x} to \kbd{s}. The value \kbd{s} must be a 24-bit signed
number.

\fun{void}{setvalp}{GEN x, long s} sets the $p$-adic or $X$-adic valuation
of~\kbd{x} to~\kbd{s}, if \kbd{x} is a \typ{PADIC} or a \typ{SER},
respectively.

\fun{void}{setprecp}{GEN x, long s} sets the $p$-adic precision of the
\typ{PADIC}~\kbd{x} to~\kbd{s}.

\fun{void}{setvarn}{GEN x, long s} sets the variable number of the \typ{POL}
or \typ{SER}~\kbd{x} to~\kbd{s} (where $0\le \kbd{s}\le\kbd{MAXVARN}$).

\subsec{Type groups}\label{se:typegroup}.
In the following macros, \kbd{t} denotes the type of a \kbd{GEN}.
Some of these macros may evaluate their argument twice. Always use them as in
\bprog
  long tx = typ(x);
  if (is_intreal_t(tx)) { }
@eprog

\fun{int}{is_recursive_t}{long t} \kbd{true} iff \kbd{t} is a recursive
type (the non-recursive types are \typ{INT}, \typ{REAL}, 
\typ{STR}, \typ{VECSMALL}). Somewhat contrary to intuition, \typ{LIST} is
also non-recursive, ; see the Developer's guide for details.

\fun{int}{is_intreal_t}{long t} \kbd{true} iff \kbd{t} is \typ{INT}
or \typ{REAL}.

\fun{int}{is_rational_t}{long t} \kbd{true} iff \kbd{t} is \typ{INT}
or \typ{FRAC}.

\fun{int}{is_vec_t}{long t} \kbd{true} iff \kbd{t} is \typ{VEC}
or \typ{COL}.

\fun{int}{is_matvec_t}{long t} \kbd{true} iff \kbd{t} is \typ{MAT}, \typ{VEC}
or \typ{COL}.

\fun{int}{is_scalar_t}{long t} \kbd{true} iff \kbd{t} is a scalar, i.e
a \typ{INT},
a \typ{REAL},
a \typ{INTMOD},
a \typ{FRAC},
a \typ{COMPLEX},
a \typ{PADIC},
a \typ{QUAD},
or
a \typ{POLMOD}.

\fun{int}{is_extscalar_t}{long t} \kbd{true} iff \kbd{t} is a scalar (see
\kbd{is\_scalar\_t}) or \kbd{t} is \typ{POL}.

\fun{int}{is_const_t}{long t} \kbd{true} iff \kbd{t} is a scalar which is not
\typ{POLMOD}.

\subsec{Accessors and components}.\label{se:accessors}
The first two functions return \kbd{GEN} components as copies on the stack:

\fun{GEN}{compo}{GEN x, long n} creates a copy of the \kbd{n}-th true
component (i.e.\ not counting the codewords) of the object~\kbd{x}.

\fun{GEN}{truecoeff}{GEN x, long n} creates a copy of the coefficient of
degree~\kbd{n} of~\kbd{x} if \kbd{x} is a scalar, \typ{POL} or \typ{SER},
and otherwise of the \kbd{n}-th component of~\kbd{x}.
\smallskip

\noindent On the contrary, the following routines return the address of a
\kbd{GEN} component. No copy is made on the stack:

\fun{GEN}{constant_term}{GEN x} returns the address the constant term of
\typ{POL}~\kbd{x}. By convention, a $0$ polynomial (whose \kbd{sign} is $0$)
has \kbd{gen\_0} constant term.

\fun{GEN}{leading_term}{GEN x} returns the address the leading term of
\typ{POL}~\kbd{x}. This may be an inexact $0$.

\fun{GEN}{gel}{GEN x, long i} returns the address of the
\kbd{x[i]} entry of~\kbd{x}. (\kbd{el} stands for element.)

\fun{GEN}{gcoeff}{GEN x, long i, long j} returns the address of the
\kbd{x[i,j]} entry of \typ{MAT}~\kbd{x}, i.e.~the coefficient at row~\kbd{i}
and column~\kbd{j}.

\fun{GEN}{gmael}{GEN x, long i, long j} returns the address of the
\kbd{x[i][j]} entry of~\kbd{x}. (\kbd{mael} stands for multidimensional array
element.)

\fun{GEN}{gmael2}{GEN A, long x1, long x2} is an alias for \kbd{gmael}.
Similar macros \tet{gmael3}, \tet{gmael4}, \tet{gmael5} are available.

\section{Handling the PARI stack}

\subsec{Allocating memory on the stack}

\fun{GEN}{cgetg}{long n, long t} allocates memory on the stack for
an object of length \kbd{n} and type~\kbd{t}, and initializes its first
codeword.

\fun{GEN}{cgeti}{long n} allocates memory on the stack for a \typ{INT}
of length~\kbd{n}, and initializes its first codeword. Identical to
\kbd{cgetg(n,\typ{INT})}.

\fun{GEN}{cgetr}{long n} allocates memory on the stack for a \typ{REAL}
of length~\kbd{n}, and initializes its first codeword. Identical to
\kbd{cgetg(n,\typ{REAL})}.

\fun{GEN}{cgetc}{long n} allocates memory on the stack for a
\typ{COMPLEX}, whose real and imaginary parts are \typ{REAL}s
of length~\kbd{n}.

\fun{GEN}{cgetp}{GEN x} creates space sufficient to hold the
\typ{PADIC}~\kbd{x}, and sets the prime $p$ and the $p$-adic precision to
those of~\kbd{x}, but does not copy (the $p$-adic unit or zero representative
and the modulus of)~\kbd{x}.

\fun{GEN}{new_chunk}{size_t n} allocates a \kbd{GEN} with $n$ components,
\emph{without} filling the required code words. This is the low-level
constructor underlying \kbd{cgetg}, which calls \kbd{new\_chunk} then sets
the first code word. It works by simply returning the address
\kbd{((GEN)avma) - n}, after checking that it is larger than \kbd{(GEN)bot}.

\fun{char*}{stackmalloc}{size_t n} allocates memory on the stack for $n$
chars (\emph{not} $n$ \kbd{GEN}s). This is faster than using \kbd{malloc},
and easier to use in most situations when temporary storage is needed. In
particular there is no need to \kbd{free} individually all variables thus
allocated: a simple \kbd{avma = oldavma} might be enough. On the other hand,
beware that this is not permanent independent storage, but part of the stack.

\noindent Objects allocated through these last two functions cannot be
\kbd{gerepile}'d. They are not valid \kbd{GEN}s since they have no PARI type.

\subsec{Garbage collection}.
See \secref{se:garbage} for a detailed explanation and many examples.

\fun{void}{cgiv}{GEN x} frees object \kbd{x}, assuming it is the last created
on the stack.

\fun{GEN}{gerepile}{pari_sp p, pari_sp q, GEN x} general garbage collector
for the stack.

\fun{void}{gerepileall}{pari_sp av, int n, ...} cleans up the stack from
\kbd{av} on (i.e from \kbd{avma} to \kbd{av}), preserving the \kbd{n} objects
which follow in the argument list (of type \kbd{GEN*}). For instance,
\kbd{gerepileall(av, 2, \&x, \&y)} preserves \kbd{x} and \kbd{y}.

\fun{void}{gerepileallsp}{pari_sp av, pari_sp ltop, int n, ...}
cleans up the stack between \kbd{av} and \kbd{ltop}, updating
the \kbd{n} elements which follow \kbd{n} in the argument list (of type
\kbd{GEN*}). Check that the elements of \kbd{g} have no component between
\kbd{av} and \kbd{ltop}, and assumes that no garbage is present between
\kbd{avma} and \kbd{ltop}. Analogous to (but faster than) \kbd{gerepileall}
otherwise.

\fun{GEN}{gerepilecopy}{pari_sp av, GEN x} cleans up the stack  from
\kbd{av} on, preserving the object \kbd{x}. Special case of \kbd{gerepileall}
(case $\kbd{n} = 1$), except that the routine returns the preserved \kbd{GEN}
instead of updating its address through a pointer.

\fun{void}{gerepilemany}{pari_sp av, GEN* g[], int n} alternative interface
to \kbd{gerepileall}

\fun{void}{gerepilemanysp}{pari_sp av, pari_sp ltop, GEN* g[], int n}
alternative interface to \kbd{gerepileallsp}.

\fun{void}{gerepilecoeffs}{pari_sp av, GEN x, int n} cleans up the stack
from \kbd{av} on, preserving \kbd{x[0]}, \dots, \kbd{x[n-1]} (which are
\kbd{GEN}s).

\fun{void}{gerepilecoeffssp}{pari_sp av, pari_sp ltop, GEN x, int n}
cleans up the stack from \kbd{av} to \kbd{ltop}, preserving \kbd{x[0]},
\dots, \kbd{x[n-1]} (which are \kbd{GEN}s). Same assumptions as in
\kbd{gerepilemanysp}, of which this is a variant. For instance
\bprog
  z = cgetg(3, t_COMPLEX);
  av = avma; garbage(); ltop = avma;
  z[1] = fun1();
  z[2] = fun2();
  gerepilecoeffssp(av, ltop, z + 1, 2);
  return z;
@eprog\noindent
cleans up the garbage between \kbd{av} and \kbd{ltop}, and connects \kbd{z}
and its two components. This is marginally more efficient than the standard
\bprog
  av = avma; garbage(); ltop = avma;
  z = cgetg(3, t_COMPLEX);
  z[1] = fun1();
  z[2] = fun2(); return gerepile(av, ltop, z);
@eprog\noindent

\fun{GEN}{gerepileupto}{pari_sp av, GEN q} analogous to (but faster than)
\kbd{gerepilecopy}. Assumes that \kbd{q} is connected and that its root was
created before any component. If \kbd{q} is not on the stack, this is
equivalent to \kbd{avma = av}; in particular, sentinels which are not even
proper \kbd{GEN}s such as \kbd{q = NULL} are allowed.

\fun{GEN}{gerepileuptoint}{pari_sp av, GEN q} analogous to (but faster than)
\kbd{gerepileupto}. Assumes further that \kbd{q} is a \typ{INT}. The
length and effective length of the resulting \typ{INT} are equal.

\fun{GEN}{gerepileuptoleaf}{pari_sp av, GEN q} analogous to (but faster than)
\kbd{gerepileupto}. Assumes further that \kbd{q} is a leaf, i.e a
non-recursive type (\kbd{is\_recursive\_t(typ(q))} is non-zero). Contrary to
\kbd{gerepileuptoint}, \kbd{gerepileuptoleaf} leaves length and effective
length of a \typ{INT} unchanged.

\fun{void}{stackdummy}{pari_sp av, pari_sp ltop} inhibits the memory area
between \kbd{av} \emph{included} and \kbd{ltop} \emph{excluded} with respect to
\kbd{gerepile}, in order to avoid a call to \kbd{gerepile(av, ltop,...)}.
The stack space is not reclaimed though.

More precisely, this routine assumes that \kbd{av} is recorded earlier
than \kbd{ltop}, then marks the specified stack segment as a
non-recursive type of the correct length. Thus gerepile will not inspect
the zone, at most copy it. To be used in the following situation:
\bprog
  av0 = avma; z = cgetg(t_VEC, 3);
  gel(z,1) = HUGE(); av = avma; garbage(); ltop = avma;
  gel(z,2) = HUGE(); stackdummy(av, ltop);
@eprog\noindent
Compared to the orthodox
\bprog
  gel(z,2) = gerepile(av, ltop, gel(z,2));
@eprog\noindent
or even more wasteful
\bprog
  z = gerepilecopy(av0, z);
@eprog\noindent
we temporarily lose $(\kbd{av} - \kbd{ltop})$ words but save a costly
\kbd{gerepile}. In principle, a garbage collection higher up the call
chain should reclaim this later anyway.

Without the \kbd{stackdummy}, if the $[\kbd{av}, \kbd{ltop}]$ zone is
arbitrary (not even valid \kbd{GEN}s as could happen after direct
truncation via \kbd{setlg}), we would leave dangerous data in the middle
of~\kbd{z}, which would be a problem for a later
\bprog
  gerepile(..., ... , z);
@eprog\noindent
And even if it were made of valid \kbd{GEN}s, inhibiting the area makes sure
\kbd{gerepile} will not inspect their components, saving time.

Another natural use in low-level routines is to ``shorten'' an existing
\kbd{GEN} \kbd{z} to its first $\kbd{n}-1$ components:
\bprog
  setlg(z, n);
  stackdummy((pari_sp)(z + lg(z)), (pari_sp)(z + n));
@eprog\noindent
or to its last \kbd{n} components:
\bprog
  long L = lg(z) - n;
  stackdummy((pari_sp)(z + L), (pari_sp)z);
  z += L; setlg(z, L);
@eprog

\subsec{Debugging the PARI stack}

\fun{int}{chk_gerepileupto}{GEN x} returns 1 if \kbd{x} is suitable for
\kbd{gerepileupto}, and 0 otherwise. In the latter case, print a warning
explaining the problem.

\fun{void}{dbg_gerepile}{pari_sp ltop} outputs the list of all objects on the
stack between \kbd{avma} and \kbd{ltop}, i.e. the ones that would be inspected
in a call to \kbd{gerepile(...,ltop,...)}.

\fun{void}{dbg_gerepileupto}{GEN q} outputs the list of all objects on the
stack that would be inspected in a call to \kbd{gerepileupto(...,q)}.

\subsec{Copies and clones}

\fun{GEN}{gclone}{GEN x} creates a new permanent copy of the object \kbd{x}
on the heap. The \emph{clone bit} of the result is set.

\fun{void}{gunclone}{GEN x} delete the clone~\kbd{x} (created by \kbd{gclone}).
Fatal error if~\kbd{x} not a clone.

\fun{GEN}{gcopy}{GEN x} creates a new copy of the object~\kbd{x} on the stack.

\fun{int}{isonstack}{GEN x} \kbd{true} iff \kbd{x} belongs to the stack. This
is a macro whose argument is evaluated several times.

\fun{void}{copyifstack}{GEN x, GEN y} sets \kbd{y = gcopy(x)} if
\kbd{x} belongs to the stack, and \kbd{y = x} otherwise. This macro evaluates
its arguments once, contrary to
\bprog
  y = isonstack(x)? gcopy(x): x;
@eprog

\fun{void}{icopyifstack}{GEN x, GEN y} as \kbd{copyifstack} assuming \kbd{x}
is a \typ{INT}.

\fun{long}{taille}{GEN x} returns the total number of \B-bit words occupied
by the tree representing~\kbd{x}.

\fun{void}{traverseheap}{void(*f)(GEN, void *), void *data} this applies
\kbd{f($x$, data)} to each object $x$ on the PARI heap, most recent
first. Mostly for debugging purposes.

\fun{GEN}{getheap}{} a simple wrapper around \kbd{traverseheap}. Returns  a
two-component row vector giving the number of objects on the heap and the
amount of memory they occupy in long words.

\section{Level 0 kernel (operations on ulongs)}

\subsec{Micro-kernel}.
The Level 0 kernel simulates basic operations of the 68020 processor on which
PARI was originally implemented. They need ``global'' \kbd{ulong} variables
\kbd{overflow} (which will contain only 0 or 1) and \kbd{hiremainder} to
function properly. However, for certain architectures these are replaced with
local variables for efficiency; and the `functions' mentioned below are
really chunks of inlined assembler code. So, a routine using one of these
lowest-level functions where the description mentions either
\kbd{hiremainder} or \kbd{overflow} must declare the corresponding
\bprog
  LOCAL_HIREMAINDER;
  LOCAL_OVERFLOW;
@eprog\noindent
in a declaration block. Variables \kbd{hiremainder} and \kbd{overflow} then
become available in the enclosing block. For instance a loop over the powers
of an \kbd{ulong}~\kbd{p} protected from overflows could read
\bprog
 while (pk < lim)
 {
   LOCAL_HIREMAINDER;
   ...
   pk = mulll(pk, p); if (hiremainder) break;
 }
@eprog

\fun{ulong}{addll}{ulong x, ulong y} adds \kbd{x} and \kbd{y}, returns the
lower \B\ bits and puts the carry bit into \kbd{overflow}.

\fun{ulong}{addllx}{ulong x, ulong y} adds \kbd{overflow} to the sum of the
\kbd{x} and \kbd{y}, returns the lower \B\ bits and puts the carry bit into
\kbd{overflow}.

\fun{ulong}{subll}{ulong x, ulong y} subtracts \kbd{x} and \kbd{y}, returns
the lower \B\ bits and put the carry (borrow) bit into \kbd{overflow}.

\fun{ulong}{subllx}{ulong x, ulong y} subtracts \kbd{overflow} from the
difference of \kbd{x} and \kbd{y}, returns the lower \B\ bits and puts the
carry (borrow) bit into \kbd{overflow}.

\fun{int}{bfffo}{ulong x} returns the number of leading zero bits in \kbd{x}.
That is, the number of bit positions by which it would have to be shifted
left until its leftmost bit first becomes equal to~1, which can be between 0
and $\B-1$ for nonzero \kbd{x}. When \kbd{x} is~0, the result is undefined.

\fun{ulong}{mulll}{ulong x, ulong y} multiplies \kbd{x} by \kbd{y}, returns
the lower \B\ bits and stores the high-order \B\ bits into \kbd{hiremainder}.

\fun{ulong}{addmul}{ulong x, ulong y} adds \kbd{hiremainder} to the product
of \kbd{x} and \kbd{y}, returns the lower \B\ bits and stores the high-order
\B\ bits into \kbd{hiremainder}.

\fun{ulong}{divll}{ulong x, ulong y} returns the Euclidean quotient of
(\kbd{hiremainder << \B})${}+{}$\kbd{x} by \kbd{y} and stores the remainder
into \kbd{hiremainder}. An error occurs if the quotient cannot be represented
by an \kbd{ulong}, i.e.~if initially $\kbd{hiremainder}\ge\kbd{y}$.

\subsec{Modular kernel}.
The following routines are not part of the level 0 kernel per se, but
implement modular operations on words in terms of the above. They are written
so that no overflow may occur. Let $m \geq 1$ be the modulus; all operands
representing classes modulo $m$ are assumed to belong to $[0,m-1]$. The
result may be wrong for a number of reasons otherwise: it may not be reduced,
overflow can occur, etc.

\fun{ulong}{Fl_add}{ulong x, ulong y, ulong m} returns the smallest
positive representative of $x + y$ modulo $m$.

\fun{ulong}{Fl_neg}{ulong x, ulong m} returns the smallest
positive representative of $-x$ modulo $m$.

\fun{ulong}{Fl_sub}{ulong x, ulong y, ulong m} returns the smallest
positive representative of $x - y$ modulo $m$.

\fun{long}{Fl_center}{ulong x, ulong m, ulong mo2} returns the representative
in $]-m/2,m/2]$ of $x$ modulo $m$. Assume $0 \leq x < m$ and
$\kbd{mo2}  = m >> 1$.

\fun{ulong}{Fl_mul}{ulong x, ulong y, ulong m} returns the smallest positive
representative of $x y$ modulo $m$.

\fun{ulong}{Fl_inv}{ulong x, ulong m} returns the smallest
positive representative of $x^{-1}$ modulo $m$. If $x$ is not invertible
mod~$m$, raise an exception.

\fun{ulong}{Fl_div}{ulong x, ulong y, ulong m} returns the smallest
positive representative of $x y^{-1}$ modulo $m$. If $y$ is not invertible
mod $m$, raise an exception.

\fun{ulong}{Fl_powu}{ulong x, ulong n, ulong m} returns the smallest
positive representative of $x^n$ modulo $m$.

\fun{ulong}{Fl_sqrt}{ulong x, ulong p} returns the square root of \kbd{x}
modulo \kbd{p} (smallest positive representative). Assumes \kbd{p} to be
prime, and \kbd{x} to be a square modulo \kbd{p}.

\fun{ulong}{random_Fl}{ulong p} returns a pseudo-random integer uniformly
distributed in $0, 1, \dots p-1$.

\fun{ulong}{pgener_Fl}{ulong p} returns a \idx{primitive root} modulo \kbd{p},
assuming \kbd{p} is prime.

\fun{ulong}{pgener_Zl}{ulong p} returns a primitive root modulo $p^k$, $k
> 1$, assuming $p$ is an odd prime. On a 64-bit machine,
this function may fail and raise an exception, if $p > 2^{63}$; namely
when $g := \kbd{pgener\_Fl}(p)$ is not a primitive element and $g + p$ no
longer fits in an \kbd{ulong}. (It turns out that this cannot happen on a
32-bit architecture.) Use \kbd{gener\_Fp} if this is a problem.

\fun{ulong}{pgener_Fl_local}{ulong p, GEN L}, see \kbd{gener\_Fp\_local},
\kbd{L} is an \kbd{Flv}.

\subsec{Switching between Fl\_xxx and standard operators}

Even though the \kbd{Fl\_xxx} routines are efficient, they are slower than
ordinary \kbd{long} operations, using the standard \kbd{+}, \kbd{\%}, etc.
operators.
The following macro is used to choose in a portable way the most efficient
functions for given operands:

\fun{int}{SMALL_ULONG}{ulong p} true if $2p^2 <2^\B$. In that case, it is
possible to use ordinary operators efficiently. If $p < 2^\B$, one
may still use the \kbd{Fl\_xxx} routines. Otherwise, one must use generic
routines. For instance, the scalar product of the \kbd{GEN}s $x$ and $y$ mod
$p$ could be computed as follows.
\bprog
    long i, l = lg(x);
    if (lgefint(p) > 3)
    { /* arbitrary */
      GEN s = gen_0;
      for (i = 1; i < l; i++) s = addii(s, mulii(gel(x,i), gel(y,i)));
      return modii(s, p).
    }
    else
    {
      ulong s = 0, pp = itou(p);
      x = ZV_to_Flv(x, pp);
      y = ZV_to_Flv(y, pp);
      if (u_SMALL_ULONG(pp))
      { /* very small */
        for (i = 1; i < l; i++)
        {
          s += x[i] * y[i];
          if (s & HIGHBIT) s %= pp;
        }
        s %= pp;
      }
      else
      { /* small */
        for (i = 1; i < l; i++)
          s = Fl_add(s, Fl_mul(x[i], y[i], pp), pp);
      }
      return utoi(s);
    }
@eprog\noindent
In effect, we have three versions of the same code: very small, small, and
arbitrary inputs. The very small and arbitrary variants use lazy reduction
and reduce only when it becomes necessary: when overflow might occur (very
small), and at the very end (very small, arbitrary).

\section{Level 1 kernel (operations on longs, integers and reals)}

\misctitle{Note:} Some functions consist of an elementary operation,
immediately followed by an assignment statement. They will be introduced as
in the following example:

\fun{GEN}{gadd[z]}{GEN x, GEN y[, GEN z]} followed by the explicit
description of the function

\kbd{GEN \key{gadd}(GEN x, GEN y)}

\noindent which creates its result on the stack, returning a \kbd{GEN} pointer
to it, and the parts in brackets indicate that there exists also a function

\kbd{void \key{gaddz}(GEN x, GEN y, GEN z)}

\noindent which assigns its result to the pre-existing object
\kbd{z}, leaving the stack unchanged. All such functions are obtained using
macros (see the file \kbd{paricom.h}), hence you can easily extend the list.
These assignment variants are kept for backward compatibility but are
inefficient: don't use them.

\subsec{Creation}

\fun{GEN}{cgeti}{long n} allocates memory on the PARI stack for a \typ{INT}
of length~\kbd{n}, and initializes its first codeword. Identical to
\kbd{cgetg(n,\typ{INT})}.

\fun{GEN}{cgetipos}{long n} allocates memory on the PARI stack for a
\typ{INT} of length~\kbd{n}, and initializes its two codewords. The sign
of \kbd{n} is set to $1$.

\fun{GEN}{cgetineg}{long n} allocates memory on the PARI stack for a negative
\typ{INT} of length~\kbd{n}, and initializes its two codewords. The sign
of \kbd{n} is set to $-1$.

\fun{GEN}{cgetr}{long n} allocates memory on the PARI stack for a \typ{REAL}
of length~\kbd{n}, and initializes its first codeword. Identical to
\kbd{cgetg(n,\typ{REAL})}.

\fun{GEN}{cgetc}{long n} allocates memory on the PARI stack for a
\typ{COMPLEX}, whose real and imaginary parts are \typ{REAL}s
of length~\kbd{n}.

\fun{GEN}{real_1}{long prec} create a \typ{REAL} equal to $1$ to \kbd{prec}
words of accuracy.

\fun{GEN}{real_m1}{long prec} create a \typ{REAL} equal to $-1$ to \kbd{prec}
words of accuracy.

\fun{GEN}{real_0_bit}{long bit} create a \typ{REAL} equal to $0$ with
exponent $-\kbd{bit}$.

\fun{GEN}{real_0}{long prec} is a shorthand for
\bprog
  real_0_bit( -bit_accuracy(prec) )
@eprog

\fun{GEN}{int2n}{long n} creates a \typ{INT} equal to \kbd{1<<n} (i.e
$2^n$ if $n \geq 0$, and $0$ otherwise).

\fun{GEN}{int2u}{ulong n} creates a \typ{INT} equal to $2^n$.

\fun{GEN}{real2n}{long n, long prec} create a \typ{REAL} equal to $2^n$
to \kbd{prec} words of accuracy.

\fun{GEN}{strtoi}{char *s} convert the character string \kbd{s} to a
non-negative \typ{INT}. The string \kbd{s} consists exclusively of digits (no
leading sign).

\fun{GEN}{strtor}{char *s, long prec} convert the character string \kbd{s}
to a non-negative \typ{REAL} of precision \kbd{prec}.
The string \kbd{s} consists exclusively of digits and optional decimal
point and exponent (no leading sign).

\subsec{Assignment}.
In this section, the \kbd{z} argument in the \kbd{z}-functions must be of type
\typ{INT} or~\typ{REAL}.

\fun{void}{mpaff}{GEN x, GEN z} assigns \kbd{x} into~\kbd{z} (where \kbd{x}
and \kbd{z} are \typ{INT} or \typ{REAL}).
Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affii}{GEN x, GEN z} assigns the \typ{INT} \kbd{x} into the
\typ{INT}~\kbd{z}.

\fun{void}{affir}{GEN x, GEN z} assigns the \typ{INT} \kbd{x} into the
\typ{REAL}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affiz}{GEN x, GEN z} assigns \typ{INT}~\kbd{x} into \typ{INT} or
\typ{REAL}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affsi}{long s, GEN z} assigns the \kbd{long}~\kbd{s} into the
\typ{INT}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affsr}{long s, GEN z} assigns the \kbd{long}~\kbd{s} into the
\typ{REAL}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affsz}{long s, GEN z} assigns the \kbd{long}~\kbd{s} into the
\typ{INT} or \typ{REAL}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affui}{ulong u, GEN z} assigns the \kbd{ulong}~\kbd{u} into the
\typ{INT}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affur}{ulong u, GEN z} assigns the \kbd{ulong}~\kbd{u} into the
\typ{REAL}~\kbd{z}. Assumes that $\kbd{lg(z)} > 2$.

\fun{void}{affrr}{GEN x, GEN z} assigns the \typ{REAL}~\kbd{x} into the
\typ{REAL}~\kbd{z}.

\fun{void}{affgr}{GEN x, GEN z} assigns the scalar \kbd{x} into the
\typ{REAL}~\kbd{z}, if possible.

\noindent The function \kbd{affrs} and \kbd{affri} do not exist. So don't use
them.

\subsec{Copy}

\fun{GEN}{icopy}{GEN x} copy relevant words of the \typ{INT}~\kbd{x} on the
stack: the length and effective length of the copy are equal.

\fun{GEN}{rcopy}{GEN x} copy the \typ{REAL}~\kbd{x} on the stack.

\fun{GEN}{mpcopy}{GEN x} copy the \typ{INT} or \typ{REAL}~\kbd{x} on the
stack. Contrary to \kbd{icopy}, \kbd{mpcopy} preserves the original length
of a \typ{INT}.

\subsec{Conversions}

\fun{GEN}{itor}{GEN x, long prec} converts the \typ{INT}~\kbd{x} to a
\typ{REAL} of length \kbd{prec} and return the latter.
Assumes that $\kbd{prec} > 2$.

\fun{long}{itos}{GEN x} converts the \typ{INT}~\kbd{x} to a \kbd{long} if
possible, otherwise raise an exception.

\fun{long}{itos_or_0}{GEN x} converts the \typ{INT}~\kbd{x} to a \kbd{long} if
possible, otherwise return $0$.

\fun{ulong}{itou}{GEN x} converts the \typ{INT}~\kbd{|x|} to an \kbd{ulong} if
possible, otherwise raise an exception.

\fun{long}{itou_or_0}{GEN x} converts the \typ{INT}~\kbd{|x|} to an
\kbd{ulong} if possible, otherwise return $0$.

\fun{GEN}{stoi}{long s} creates the \typ{INT} corresponding to the
\kbd{long}~\kbd{s}.

\fun{GEN}{stor}{long s, long prec} converts the \kbd{long}~\kbd{s} into a
\typ{REAL} of length \kbd{prec} and return the latter. Assumes that
$\kbd{prec} > 2$.

\fun{GEN}{utoi}{ulong s} converts the \kbd{ulong}~\kbd{s} into a \typ{INT}
and return the latter.

\fun{GEN}{utoipos}{ulong s} converts the \emph{non-zero} \kbd{ulong}~\kbd{s}
into a \typ{INT} and return the latter.

\fun{GEN}{utoineg}{ulong s} converts the \emph{non-zero} \kbd{ulong}~\kbd{s}
into a \typ{INT} and return the latter.

\fun{GEN}{utor}{ulong s, long prec} converts the \kbd{ulong}~\kbd{s} into a
\typ{REAL} of length \kbd{prec} and return the latter. Assumes that
$\kbd{prec} > 2$.

\fun{GEN}{rtor}{GEN x, long prec} converts the \typ{REAL}~\kbd{x} to a
\typ{REAL} of length \kbd{prec} and return the latter. If
$\kbd{prec} < \kbd{lg(x)}$, round properly. If $\kbd{prec} > \kbd{lg(x)}$,
padd with zeroes. Assumes that $\kbd{prec} > 2$.

\noindent The following function is also available as a special case of
\tet{mkintn}:

\fun{GEN}{u2toi}{ulong a, ulong b} returns the \kbd{GEN} equal to $2^{32} a +
b$, \emph{assuming} that $a,b < 2^{32}$. This does not depend on
\kbd{sizeof(long)}: the behaviour is as above on both $32$ and $64$-bit
machines.

\subsec{Integer parts}
The following four functions implement the conversion from \typ{REAL} to
\typ{INT} using standard rounding modes. Contrary to usual semantics
(complement the mantissa with an infinite number of 0), they will raise an
error \emph{precision loss in truncation} if the \typ{REAL} represents a
range containing more than one integer.

\fun{GEN}{ceilr}{GEN x} smallest integer larger or equal
to the \typ{REAL}~\kbd{x} (i.e.~the \kbd{ceil} function).

\fun{GEN}{floorr}{GEN x} largest integer smaller or equal to the
\typ{REAL}~\kbd{x} (i.e.~the \kbd{floor} function).

\fun{GEN}{roundr}{GEN x} rounds the \typ{REAL} \kbd{x} to the nearest integer
(towards~$+\infty$).

\fun{GEN}{truncr}{GEN x} truncates the \typ{REAL}~\kbd{x} (not the same as
\kbd{floorr} if \kbd{x} is and negative).

The following four function are analogous, but can also treat the trivial
case when the argument is a \typ{INT}:

\fun{GEN}{mpceil}{GEN x}
as \kbd{ceilr} except that \kbd{x} may be a \typ{INT}.

\fun{GEN}{mpfloor}{GEN x}
as \kbd{floorr} except that \kbd{x} may be a \typ{INT}.

\fun{GEN}{mpround}{GEN x}
as \kbd{roundr} except that \kbd{x} may be a \typ{INT}.

\fun{GEN}{mptrunc}{GEN x}
as \kbd{truncr} except that \kbd{x} may be a \typ{INT}.

\fun{GEN}{diviiround}{GEN x, GEN y} if \kbd{x} and \kbd{y} are \typ{INT}s,
returns the quotient $\kbd{x}/\kbd{y}$ of \kbd{x} and~\kbd{y}, rounded to
the nearest integer. If $\kbd{x}/\kbd{y}$ falls exactly halfway between
two consecutive integers, then it is rounded towards~$+\infty$ (as for
\tet{roundr}).

\fun{GEN}{ceil_safe}{GEN x}, \kbd{x} being a real number (not necessarily a
\typ{REAL}) returns an integer which is larger than any possible incarnation
of \kbd{x}. (Recall that a \typ{REAL} represents an interval of possible
values.)

\fun{GEN}{floor_safe}{GEN x}, \kbd{x} being a real number (not necessarily a
\typ{REAL}) returns an integer which is smaller than any possible incarnation
of \kbd{x}. (Recall that a \typ{REAL} represents an interval of possible
values.)

\subsec{Valuation and shift}

\fun{long}{vals}{long s} 2-adic valuation of the \kbd{long}~\kbd{s}. Returns
$-1$ if \kbd{s} is equal to 0.

\fun{long}{vali}{GEN x} 2-adic valuation of the \typ{INT}~\kbd{x}. Returns $-1$
if \kbd{x} is equal to 0.

\fun{GEN}{mpshift}{GEN x, long n} shifts the~\typ{INT} or
\typ{REAL} \kbd{x} by~\kbd{n}. If \kbd{n} is positive, this is a left shift,
i.e.~multiplication by $2^{\kbd{n}}$. If \kbd{n} is negative, it is a right
shift by~$-\kbd{n}$, which amounts to the truncation of the quotient of \kbd{x}
by~$2^{-\kbd{n}}$.

\fun{GEN}{shifti}{GEN x, long n} shifts the \typ{INT}~\kbd{x} by~\kbd{n}.

\fun{GEN}{shiftr}{GEN x, long n} shifts the \typ{REAL}~\kbd{x} by~\kbd{n}.

\fun{long}{Z_pvalrem}{GEN x, GEN p, GEN *r} applied to \typ{INT}s
$\kbd{x}\neq 0$ and~\kbd{p}, $|\kbd{p}| > 1$, returns the highest
exponent $e$ such that $\kbd{p}^{e}$ divides~\kbd{x}. The quotient
$\kbd{x}/\kbd{p}^{e}$ is returned in~\kbd{*r}. In particular, if \kbd{p} is a
prime, this returns the valuation at \kbd{p} of~\kbd{x}, and \kbd{*r} is
the prime-to-\kbd{p} part of~\kbd{x}.

\fun{long}{Z_pval}{GEN x, GEN p} as \kbd{Z\_pvalrem} but only returns the
``valuation''.

\fun{long}{Z_lvalrem}{GEN x, ulong p, GEN *r} as \kbd{Z\_pvalrem}, except
that \kbd{p} is an \kbd{ulong} ($\kbd{p} > 1$).

\fun{long}{Z_lval}{GEN x, ulong p} as \kbd{Z\_pval}, except
that \kbd{p} is an \kbd{ulong} ($\kbd{p} > 1$).

\fun{long}{u_lvalrem}{ulong x, ulong p, ulong *r} as \kbd{Z\_pvalrem},
except the inputs/outputs are now \kbd{ulong}s.

\fun{long}{u_pvalrem}{ulong x, GEN p, ulong *r} as \kbd{Z\_pvalrem},
except \kbd{x} and \kbd{r} are now \kbd{ulong}s.

\fun{long}{u_lval}{ulong x, ulong p} as \kbd{Z\_pval},
except the inputs/outputs are now \kbd{ulong}s.

\fun{long}{z_pval}{long x, GEN p} as \kbd{Z\_pval},
except \kbd{x} is now a \kbd{long}.

\fun{long}{Q_pval}{GEN x, GEN p} valuation at the \typ{INT} \kbd{p}
of the \typ{INT} or \typ{FRAC}~\kbd{x}.

\subsec{Factorization}

\fun{GEN}{Z_factor}{GEN n} factors the \typ{INT} \kbd{n}. The ``primes''
in the factorization are actually strong pseudoprimes.

\fun{int}{is_Z_factor}{GEN f} returns $1$ if $f$ looks like the factorization
of a positive integer, and $0$ otherwise. Useful for sanity checks but not
100\% foolproof. Specifically, this routine checks that $f$ is a two-column
matrix all of whose entries are positive integers.

\fun{long}{Z_issquarefree}{GEN x} returns $1$ if the \typ{INT} \kbd{n}
is square-free, and $0$ otherwise.

\fun{long}{isfundamental}{GEN x} returns $1$ if the \typ{INT} \kbd{x}
is a fundamental discriminant, and $0$ otherwise.

\fun{long}{Z_issquare}{GEN n} returns $1$ if \typ{INT} \kbd{n} is
a square, and $0$ otherwise. This is tested first modulo small prime
powers, then \kbd{sqrtremi} is called.

\fun{long}{Z_issquarerem}{GEN n, GEN *sqrtn} as \kbd{Z\_issquare}. If
\kbd{n} is indeed a square, set \kbd{sqrtn} to its integer square root.

\fun{int}{isprime}{GEN n}, returns $1$ if the \typ{INT} \kbd{n} is a
(fully proven) prime number and $0$ otherwise.

\fun{long}{BSW_psp}{GEN n}, returns $1$ if the \typ{INT} \kbd{n} is a
Baillie-Pomerance-Selfridge-Wagstaff pseudoprime, and $0$ otherwise.

\fun{int}{uisprime}{ulong p}, returns $1$ if \kbd{p} is a prime number and
$0$ otherwise.

\fun{long}{Z_issquarerem}{GEN n, GEN *sqrtn} as \kbd{Z\_issquare}. If
\kbd{n} is indeed a square, set \kbd{sqrtn} to its integer square root.

\fun{long}{uissquarerem}{ulong n, ulong *sqrtn} as \kbd{Z\_issquarerem},
for an \kbd{ulong} operand \kbd{n}.

\fun{GEN}{Z_factor_limit}{GEN n, GEN lim} as \kbd{Z\_factor}, but stop the
factorization process as soon as the unfactored part is smaller than \kbd{lim}.
The resulting factorisation matrix only contains the factors found. No other
assumptions can be made on the remaining factors.

\fun{GEN}{boundfact}{GEN x, long lim} trial divide $x$ by all primes $p <
\kbd{lim}$ and return the corresponding factorization matrix. In this case,
the last ``prime'' divisor in the first column of the factorization matrix
may well be a proven composite.

This requires \kbd{primelimit} to be larger than \kbd{lim}. If \kbd{lim} is
zero, the effect is the same as setting $\kbd{lim} = \kbd{primelimit}$.

\fun{GEN}{core}{GEN n} unique squarefree integer $d$ dividing $n$ such that
$n/d$ is a square.

\fun{GEN}{core2}{GEN n} return $[d,f]$ with $d$ squarefree and $n = df^2$.

\fun{GEN}{corepartial}{GEN n, long lim} as \kbd{core}, using
\kbd{boundfact(n,lim)} to partially factor \kbd{n}. The result is not
necessarily squarefree, but $p^2 \mid n$ implies $p > \kbd{lim}$.

\fun{GEN}{core2partial}{GEN n, long lim} as \kbd{core2}, using
\kbd{boundfact(n,lim)} to partially factor \kbd{n}. The resulting $d$ is not
necessarily squarefree, but $p^2 \mid n$ implies $p > \kbd{lim}$.

\subsec{Generic unary operators}. Let ``\op'' be a unary operation among

\op=\key{neg}: negation ($-$\kbd{x}).


\op=\key{abs}: absolute value ($|\kbd{x}|$).

\noindent The names and prototypes of the low-level functions corresponding
to \op\ are as follows. The result is of the same type as~\kbd{x}.

\funno{GEN}{mp\op}{GEN x} creates the result of \op\ applied to the
\typ{INT} or \typ{REAL}~\kbd{x}.

\funno{GEN}{\op i}{GEN x} creates the result of \op\ applied to the
\typ{INT}~\kbd{x}.

\funno{GEN}{\op r}{GEN x} creates the result of \op\ applied to the
\typ{REAL}~\kbd{x}.

\funno{GEN}{mp\op z}{GEN x, GEN z} assigns the result of applying \op\ to the
\typ{INT} or \typ{REAL}~\kbd{x} into the \typ{INT} or \typ{REAL}~\kbd{z}.

\misctitle{Remark:} it has not been considered useful to include
functions {\tt void \op sz(long,GEN)}, {\tt void \op iz(GEN,GEN)} and
{\tt void \op rz(GEN, GEN)}.
\smallskip

\subsec{Comparison operators}

\fun{int}{mpcmp}{GEN x, GEN y} compares the \typ{INT} or \typ{REAL}~\kbd{x}
to the \typ{INT} or \typ{REAL}~\kbd{y}. The result is the sign of
$\kbd{x}-\kbd{y}$.

\fun{int}{cmpii}{GEN x, GEN y} compares the \typ{INT} \kbd{x} to the
\typ{INT}~\kbd{y}.

\fun{int}{cmpir}{GEN x, GEN y} compares the \typ{INT} \kbd{x} to the
\typ{REAL}~\kbd{y}.

\fun{int}{cmpis}{GEN x, long s} compares the \typ{INT}~\kbd{x} to the
\kbd{long}~\kbd{s}.

\fun{int}{cmpsi}{long s, GEN x} compares the \kbd{long}~\kbd{s} to the
\typ{INT}~\kbd{x}.

\fun{int}{cmpsr}{long s, GEN x} compares the \kbd{long}~\kbd{s} to the
\typ{REAL}~\kbd{x}.

\fun{int}{cmpri}{GEN x, GEN y} compares the \typ{REAL}~\kbd{x} to the
\typ{INT}~\kbd{y}.

\fun{int}{cmprr}{GEN x, GEN y} compares the \typ{REAL}~\kbd{x} to the
\typ{REAL}~\kbd{y}.

\fun{int}{cmprs}{GEN x, long s} compares the \typ{REAL}~\kbd{x} to the
\kbd{long}~\kbd{s}.

\fun{int}{equalii}{GEN x, GEN y} compares the \typ{INT}s \kbd{x} and~\kbd{y}.
The result is $1$ if $\kbd{x} = \kbd{y}$, $0$ otherwise.

\fun{int}{equalsi}{long s, GEN x}

\fun{int}{equalis}{GEN x, long s} compare the \typ{INT} \kbd{x} and
the \kbd{long}~\kbd{s}. The result is $1$ if $\kbd{x} = \kbd{y}$, $0$ otherwise.

The remaining comparison operators disregard the sign of their operands:

\fun{int}{equalui}{ulong s, GEN x}

\fun{int}{equaliu}{GEN x, ulong s} compare the absolute value of the
\typ{INT} \kbd{x} and the \kbd{ulong}~\kbd{s}. The result is $1$ if
$|\kbd{x}| = \kbd{y}$, $0$ otherwise.

\fun{int}{cmpui}{ulong u, GEN x}

\fun{int}{cmpiu}{GEN x, ulong u} compare the absolute value of the
\typ{INT} \kbd{x} and the \kbd{ulong}~\kbd{s}.

\fun{int}{absi_cmp}{GEN x, GEN y} compares the \typ{INT}s \kbd{x} and~\kbd{y}.
The result is the sign of $|\kbd{x}| - |\kbd{y}|$.

\fun{int}{absi_equal}{GEN x, GEN y} compares the \typ{INT}s \kbd{x}
and~\kbd{y}. The result is $1$ if $|\kbd{x}| = |\kbd{y}|$, $0$ otherwise.

\fun{int}{absr_cmp}{GEN x, GEN y} compares the \typ{REAL}s \kbd{x} and~\kbd{y}.
The result is the sign of $|\kbd{x}| - |\kbd{y}|$.

\subsec{Generic binary operators}. Let ``\op'' be a binary operation among

\op=\key{add}: addition (\kbd{x + y}). The result is a \typ{REAL} unless both
\kbd{x} and \kbd{y} are integer types (\typ{INT}, \kbd{long} or \kbd{ulong}).

\op=\key{sub}: subtraction (\kbd{x - y}). The result is a \typ{REAL} unless both
\kbd{x} and \kbd{y} are integer types.

\op=\key{mul}: multiplication (\kbd{x * y}). The result is a \typ{REAL}
unless both \kbd{x} and \kbd{y} are integer types, \emph{or} if
\kbd{x} or \kbd{y} is an exact $0$.

\op=\key{div}: division (\kbd{x / y}). In the case where \kbd{x} and \kbd{y}
are both integer types, the result is the Euclidean quotient, where the
remainder has the same sign as the dividend~\kbd{x}. It is the ordinary
division otherwise. If one of \kbd{x} or \kbd{y} is a \typ{REAL}, the result
is a \typ{REAL} unless \kbd{x} is an exact $0$. A division-by-$0$ error
occurs if \kbd{y} is equal to $0$.

\op=\key{rem}: remainder (``\kbd{x \% y}''). This operation is defined only
when \kbd{x} and \kbd{y} are integer types. The result is the Euclidean
remainder corresponding to \kbd{div},~i.e. its sign is that of the
dividend~\kbd{x}. The result is always a \typ{INT}.

\op=\key{mod}: true remainder (\kbd{x \% y}). This operation is defined only
when \kbd{x} and \kbd{y} are longs or \typ{INT}s. The result is the true
Euclidean remainder, i.e.~non-negative and less than the absolute value
of~\kbd{y}.

\noindent The names and prototypes of the low-level functions corresponding
to \op\ are as follows. In this section, the \kbd{z} argument in the
\kbd{z}-functions must be of type \typ{INT} when no \kbd{r} or \kbd{mp}
appears in the argument code (no \typ{REAL} operand is involved, only integer
types), and of type \typ{REAL} otherwise.

\funno{GEN}{mp\op[z]}{GEN x, GEN y[, GEN z]} applies \op\ to
the \typ{INT} or \typ{REAL} \kbd{x} and~\kbd{y}. The function
\kbd{mpdivz} does not exist (its semantic would change drastically
depending on the type of the \kbd{z} argument).

\funno{GEN}{\op si[z]}{long s, GEN x[, GEN z]} applies \op\ to the
\kbd{long}~\kbd{s} and the \typ{INT}~\kbd{x}.

\funno{GEN}{\op sr[z]}{long s, GEN x[, GEN z]} applies \op\ to the
\kbd{long}~\kbd{s} and the \typ{REAL}~\kbd{x}.

\funno{GEN}{\op ss[z]}{long s, long t[, GEN z]} applies \op\ to the longs
\kbd{s} and~\kbd{t}.

\funno{GEN}{\op ii[z]}{GEN x, GEN y[, GEN z]} applies \op\ to the
\typ{INT}s \kbd{x} and~\kbd{y}.

\funno{GEN}{\op ir[z]}{GEN x, GEN y[, GEN z]} applies \op\ to the
\typ{INT} \kbd{x} and the \typ{REAL}~\kbd{y}.

\funno{GEN}{\op is[z]}{GEN x, long s[, GEN z]} applies \op\ to the
\typ{INT}~\kbd{x} and the \kbd{long}~\kbd{s}.

\funno{GEN}{\op ri[z]}{GEN x, GEN y[, GEN z]} applies \op\ to the
\typ{REAL}~\kbd{x} and the \typ{INT}~\kbd{y}.

\funno{GEN}{\op rr[z]}{GEN x, GEN y[, GEN z]} applies \op\ to the
\typ{REAL}s~\kbd{x} and~\kbd{y}.

\funno{GEN}{\op rs[z]}{GEN x, long s[, GEN z]} applies \op\ to the
\typ{REAL}~\kbd{x} and the \kbd{long}~\kbd{s}.

\noindent Some miscellaneous routines:

\fun{long}{expu}{ulong x} assuming $x > 0$, returns the binary exponent of
the real number equal to $x$. This is a special case of \kbd{gexpo}.

\fun{GEN}{adduu}{ulong x, ulong y} adds \kbd{x} by \kbd{y}.

\fun{GEN}{subuu}{ulong x, ulong y} subtracts \kbd{x} by \kbd{y}.

\fun{GEN}{muluu}{ulong x, ulong y} multiplies \kbd{x} by \kbd{y}.

\fun{GEN}{mului}{ulong x, GEN y} multiplies \kbd{x} by \kbd{y}.

\fun{GEN}{muliu}{GEN x, ulong y} multiplies \kbd{x} by \kbd{y}.

\fun{GEN}{sqri}{GEN x} squares the \typ{INT}~\kbd{x}

\fun{GEN}{truedivii}{GEN x, GEN y} returns the true Euclidean quotient
(with non-negative remainder less than $|y|$).

\fun{GEN}{truedivis}{GEN x, long y} returns the true Euclidean quotient
(with non-negative remainder less than $|y|$).

\fun{GEN}{centermodii}{GEN x, GEN y, GEN y2}, given
\typ{INT}s \kbd{x}, \kbd{y}, returns $z$ congruent to \kbd{x} modulo \kbd{y},
such that $-\kbd{y}/2 \leq z < \kbd{y}/2$. Assumes that \kbd{y2 = shifti(y,
-1)}. the representative of ssquares the \typ{INT}~\kbd{x}

\fun{GEN}{remi2n}{GEN x, long n} returns \kbd{x} mod $2^n$.

\subsec{Modulo to longs}. The following variants of \kbd{modii} do not
clutter the stack:

\fun{long}{smodis}{GEN x, long y} computes the true Euclidean
remainder of the \typ{INT}~\kbd{x} by the \kbd{long}~\kbd{y}. This is the
non-negative remainder, not the one whose sign is the sign of \kbd{x}
as in the \kbd{div} functions.

\fun{long}{smodsi}{long x, GEN y} computes the true Euclidean
remainder of the \kbd{long}~\kbd{x} by a \typ{INT}~\kbd{y}.

\fun{long}{smodss}{long x, long y} computes the true Euclidean
remainder of the \kbd{long}~\kbd{x} by a \kbd{long}~\kbd{y}.

\fun{ulong}{umodiu}{GEN x, ulong y} computes the true Euclidean
remainder of the \typ{INT}~\kbd{x} by the \kbd{ulong}~\kbd{y}.

\fun{ulong}{umodui}{ulong x, GEN y} computes the true Euclidean
remainder of the \kbd{ulong}~\kbd{x} by the \typ{INT}~\kbd{|y|}.

The routine \tet{smodsi} does not exist, since it would not always be
defined: for a \emph{negative} \kbd{x}, its result \kbd{x + |y|} would
in general not fit into a \kbd{long}. Use either \kbd{umodui} or
\kbd{modsi}.

\subsec{Exact division and divisibility}

\fun{void}{diviiexact}{GEN x, GEN y} returns the Euclidean quotient
$\kbd{x} / \kbd{y}$, assuming $\kbd{y}$ divides $\kbd{x}$. Uses Jebelean
algorithm (Jebelean-Krandick bidirectional exact division is not
implemented).

\fun{void}{diviuexact}{GEN x, ulong y} returns the Euclidean quotient
$|\kbd{x}| / \kbd{y}$, assuming $\kbd{y}$ divides
$\kbd{x}$ and $\kbd{y}$ is non-zero. (Note the absolute value!)

The following routines return 1 (true) if \kbd{y} divides \kbd{x}, and
0 otherwise. All \kbd{GEN} are assumed to be \typ{INT}s.
\fun{int}{dvdii}{GEN x, GEN y}
\fun{int}{dvdis}{GEN x, long y}
\fun{int}{dvdiu}{GEN x, ulong y}
\fun{int}{dvdsi}{long x, GEN y}
\fun{int}{dvdui}{ulong x, GEN y}

The following routines return 1 (true) if \kbd{y} divides \kbd{x}, and in
that case assign the quotient to \kbd{z}; otherwise they return 0. All
\kbd{GEN} are assumed to be \typ{INT}s.
\fun{int}{dvdiiz}{GEN x, GEN y, GEN z}
\fun{int}{dvdisz}{GEN x, long y, GEN z}
\fun{int}{dvdiuz}{GEN x, ulong y, GEN z} if \kbd{y} divides \kbd{x}, assigns
the quotient $|\kbd{x}|/\kbd{y}$ to \kbd{z} and returns 1 (true), otherwise
returns 0 (false).

\subsec{Division with remainder}. The following functions return two objects,
unless specifically asked for only one of them~--- a quotient and a remainder.
The quotient is returned and the remainder is returned through the variable
whose address is passed as the \kbd{r} argument. The term \emph{true
Euclidean remainder} refers to the non-negative one (\kbd{mod}), and
\emph{Euclidean remainder} by itself to the one with the same sign as the
dividend (\kbd{rem}). All \kbd{GEN}s, whether returned directly or through a
pointer, are created on the stack.

\fun{GEN}{dvmdii}{GEN x, GEN y, GEN *r} returns the Euclidean quotient of the
\typ{INT}~\kbd{x} by a \typ{INT}~\kbd{y} and puts the remainder
into~\kbd{*r}. If \kbd{r} is equal to \kbd{NULL}, the remainder is not
created, and if \kbd{r} is equal to  \kbd{ONLY\_REM}, only the remainder is
created and returned. In the generic case, the remainder is created after the
quotient and can be disposed of individually with a \kbd{cgiv(r)}. The
remainder is always of the sign of the dividend~\kbd{x}. If the remainder
is $0$ set \kbd{r = gen\_0}.

\fun{void}{dvmdiiz}{GEN x, GEN y, GEN z, GEN t} assigns the Euclidean
quotient of the \typ{INT}s \kbd{x} and \kbd{y} into the \typ{INT} or
\typ{REAL}~\kbd{z}, and the Euclidean remainder into the \typ{INT} or
\typ{REAL}~\kbd{t}.

\noindent Analogous routines \tet{dvmdis}\kbd{[z]}, \tet{dvmdsi}\kbd{[z]},
\tet{dvmdss}\kbd{[z]} are available, where \kbd{s} denotes a \kbd{long}
argument. But the following routines are in general more flexible:

\fun{long}{sdivss_rem}{long s, long t, long *r} computes the Euclidean
quotient and remainder of the longs \kbd{s} and~\kbd{t}. Puts the remainder
into \kbd{*r}, and returns the quotient. The remainder is of the sign of the
dividend~\kbd{s}, and has strictly smaller absolute value than~\kbd{t}.

\fun{long}{sdivsi_rem}{long s, GEN x, long *r} computes the Euclidean
quotient and remainder of the \kbd{long}~\kbd{s} by the \typ{INT}~\kbd{x}. As
\kbd{sdivss\_rem} otherwise.

\fun{long}{sdivsi}{long s, GEN x} as \kbd{sdivsi\_rem}, without
remainder.

\fun{GEN}{divis_rem}{GEN x, long s, long *r} computes the Euclidean quotient
and remainder of the \typ{INT}~\kbd{x} by the \kbd{long}~\kbd{s}. As
\kbd{sdivss\_rem} otherwise.

\fun{GEN}{diviu_rem}{GEN x, ulong s, long *r} computes the Euclidean quotient
and remainder of the \typ{INT}~\kbd{x} by the \kbd{ulong}~\kbd{s}. As
\kbd{sdivss\_rem} otherwise.

\fun{GEN}{divsi_rem}{long s, GEN y, long *r} computes the Euclidean quotient
and remainder of the \typ{long}~\kbd{s} by the \kbd{GEN}~\kbd{y}. As
\kbd{sdivss\_rem} otherwise.

\fun{GEN}{divss_rem}{long x, long y, long *r} computes the Euclidean quotient
and remainder of the \typ{long}~\kbd{x} by the \kbd{long}~\kbd{y}. As
\kbd{sdivss\_rem} otherwise.
\smallskip
\fun{GEN}{truedvmdii}{GEN x, GEN y, GEN *r}, as \kbd{dvmdii} but with a
non-negative remainder.

\fun{GEN}{truedvmdis}{GEN x, long y, GEN *z}, as \kbd{dvmdis} but with a
non-negative remainder.

\subsec{Square root and remainder}

\fun{GEN}{sqrtremi}{GEN N, GEN *r}, returns the integer square root $S$ of
the non-negative \typ{INT}~\kbd{N} (rounded towards 0) and puts the remainder
$R$ into~\kbd{*r}. Precisely, $N = S^2 + R$ with $0\leq R \leq 2S$. If
\kbd{r} is equal to \kbd{NULL}, the remainder is not created. In the generic
case, the remainder is created after the quotient and can be disposed of
individually with \kbd{cgiv(R)}. If the remainder is $0$ set \kbd{R = gen\_0}.

Uses a divide and conquer algorithm (discrete variant of Newton iteration)
due to Paul Zimmermann (``Karatsuba Square Root'', INRIA Research Report 3805
(1999)).

\fun{GEN}{sqrti}{GEN N}, returns the integer square root $S$ of
the non-negative \typ{INT}~\kbd{N} (rounded towards 0). This is identical
to \kbd{sqrtremi(N, NULL)}.

\subsec{Cached constants}

The cached constant is returned at its current precision, which may be larger
than \kbd{prec}. One should always use the \kbd{mp\var{xxx}} variant:
\kbd{mppi}, \kbd{mpeuler}, or \kbd{mplog2}.

\fun{GEN}{consteuler}{long prec} precomputes Euler-Mascheroni's constant
at precision \kbd{prec}.

\fun{GEN}{constpi}{long prec} precomputes $\pi$ at precision \kbd{prec}.

\fun{GEN}{constlog2}{long prec} precomputes $\log(2)$ at precision
\kbd{prec}.

\fun{void}{mpbern}{long n, long prec} precomputes the even \idx{Bernoulli}
numbers $B_0,\dots,B_{2n-2}$ as \typ{REAL}s of precision \kbd{prec}.

\fun{GEN}{bern}{long i} is a macro returning the \idx{Bernoulli} number
$B_{2i}$ at precision \kbd{prec}, assuming that \kbd{mpbern(n, prec)} was
called previously with $n > i$. The macro does not check whether
$0 \leq i < n$. If cached Bernoullis were initialized to a larger accuracy
than desired, use e.g.~\kbd{rtor(bern(i), prec)}.

The following functions use cached data if \kbd{prec} is not too large;
otherwise the newly computed data replaces the old cache.

\fun{GEN}{mppi}{long prec} returns $\pi$ at precision \kbd{prec}.

\fun{GEN}{Pi2n}{long n, long prec} returns $2^n\pi$ at precision \kbd{prec}.

\fun{GEN}{PiI2}{long n, long prec} returns the complex number $2\pi i$ at
precision \kbd{prec}.

\fun{GEN}{PiI2n}{long n, long prec} returns the complex number $2^n\pi i$ at
precision \kbd{prec}.

\fun{GEN}{mpeuler}{long prec} returns Euler-Mascheroni's constant at
precision \kbd{prec}.

\fun{GEN}{mplog2}{long prec} returns $\log 2$ at precision \kbd{prec}.


\subsec{Pseudo-random integers}
These routine return pseudo-random integers uniformly distributed in some
interval. The all use the same underlying generator which can be seeded and
restarted using \tet{getrand} and \tet{setrand}.

\fun{ulong}{pari_rand}{void} returns a random $0 \leq x < 2^\B$.

\fun{long}{random_bits}{long k} returns a random $0 \leq x < 2^k$. Assumes
that $0 \leq k \leq \B$.

\fun{ulong}{random_Fl}{ulong p} returns a pseudo-random integer
in $0, 1, \dots p-1$.

\fun{GEN}{randomi}{GEN n} returns a random \typ{INT} between $0$ and $\kbd{n}
- 1$.

\subsec{Modular operations}. In this subsection, all \kbd{GEN}s are \typ{INT}.

\fun{GEN}{Fp_neg}{GEN a, GEN m} returns $-$\kbd{a} modulo \kbd{m} (smallest
non-negative residue).

\fun{GEN}{Fp_add}{GEN a, GEN b, GEN m} returns the sum of \kbd{a} and
\kbd{b} modulo \kbd{m} (smallest non-negative residue).

\fun{GEN}{Fp_sub}{GEN a, GEN b, GEN m} returns the difference of \kbd{a} and
\kbd{b} modulo \kbd{m} (smallest non-negative residue).

\fun{GEN}{Fp_mul}{GEN a, GEN b, GEN m} returns the product of \kbd{a} by
\kbd{b} modulo \kbd{m} (smallest non-negative residue).

\fun{GEN}{Fp_sqr}{GEN a, GEN m} returns $\kbd{a}^2$ modulo \kbd{m} (smallest
non-negative residue).

\fun{ulong}{Fp_powu}{GEN x, ulong n, GEN m} raises \kbd{x} to the \kbd{n}-th
power modulo \kbd{p} (smallest non-negative residue). Not memory-clean, but
suitable for \kbd{gerepileupto}.

\fun{ulong}{Fp_pows}{GEN x, long n, GEN m} raises \kbd{x} to the \kbd{n}-th
power modulo \kbd{p} (smallest non-negative residue). A negative \kbd{n} is
allowed Not memory-clean, but suitable for \kbd{gerepileupto}.

\fun{GEN}{Fp_pow}{GEN x, GEN n, GEN m} returns $\kbd{x}^\kbd{n}$
modulo \kbd{p} (smallest non-negative residue).

\fun{GEN}{Fp_inv}{GEN a, GEN m} returns an inverse of \kbd{a} modulo \kbd{m}
(smallest non-negative residue). Raise an error if \kbd{a} is not invertible.

\fun{GEN}{Fp_invsafe}{GEN a, GEN m} as \kbd{Fp\_inv}, but return
\kbd{NULL} if \kbd{a} is not invertible.

\fun{GEN}{Fp_div}{GEN a, GEN b, GEN m} returns the quotient of \kbd{a} by
\kbd{b} modulo \kbd{m} (smallest non-negative residue). Raise an error if
\kbd{b} is not invertible.

\fun{int}{invmod}{GEN a, GEN m, GEN *g},  return $1$ if \kbd{a}
modulo \kbd{m} is invertible, else return $0$ and set
$\kbd{g} = \gcd(\kbd{a},\kbd{m})$.

\fun{GEN}{Fp_log}{GEN a, GEN g, GEN ord, GEN p} Let $g$ such that $g^ord=1
\pmod{p}$. Return an integer $e$ such that $a^e=g \pmod{p}$. If $e$ does not
exists, the result is currently undefined.

\fun{GEN}{Fp_order}{GEN a, GEN ord, GEN p} returns the order of the
\typ{Fp} \kbd{a}. If \kbd{o} is non-\kbd{NULL}, it is assumed that \kbd{o}
is a multiple of the order of \kbd{a}, either as a \typ{INT} or a
factorization matrix.

\fun{GEN}{Fp_sqrt}{GEN x, GEN p} returns a square root of \kbd{x} modulo
\kbd{p} (the smallest non-negative residue), where \kbd{x}, \kbd{p} are
\typ{INT}s, and \kbd{p} is assumed to be prime. Return \kbd{NULL}
if \kbd{x} is not a quadratic residue modulo \kbd{p}.

\fun{GEN}{Fp_sqrtn}{GEN x, GEN n, GEN p, GEN *zn} returns an \kbd{n}-th
root of $\kbd{x}$ modulo \kbd{p} (smallest non-negative residue), where
\kbd{x}, \kbd{n}, \kbd{p} are \typ{INT}s, and \kbd{p} is assumed to be prime.
Return \kbd{NULL} if \kbd{x} is not an \kbd{n}-th power residue. Otherwise,
if \kbd{zn} is non-\kbd{NULL} set it to a primitive \kbd{n}-th root of $1$.

\fun{long}{kross}{long x, long y} returns the \idx{Kronecker symbol} $(x|y)$,
i.e.$-1$, $0$ or $1$. If \kbd{y} is an odd prime, this is the \idx{Legendre
symbol}. (Contrary to \kbd{krouu}, \kbd{kross} also supports $\kbd{y} = 0$)

\fun{long}{krouu}{ulong x, ulong y} returns the \idx{Kronecker symbol}
$(x|y)$, i.e.~$-1$, $0$ or $1$. Assumes \kbd{y} is non-zero. If \kbd{y} is an
odd prime, this is the \idx{Legendre symbol}.

\fun{long}{krois}{GEN x, long y} returns the \idx{Kronecker symbol} $(x|y)$
of \typ{INT}~x and \kbd{long}~\kbd{y}. As \kbd{kross} otherwise.

\fun{long}{krosi}{long x, GEN y} returns the \idx{Kronecker symbol} $(x|y)$
of \kbd{long}~x and \typ{INT}~\kbd{y}. As \kbd{kross} otherwise.

\fun{long}{kronecker}{GEN x, GEN y} returns the \idx{Kronecker symbol} $(x|y)$
of \typ{INT}s~x and~\kbd{y}. As \kbd{kross} otherwise.

\fun{GEN}{pgener_Fp}{GEN p} returns a primitive root modulo \kbd{p}, assuming
\kbd{p} is prime.

\fun{GEN}{pgener_Zp}{GEN p} returns a primitive root modulo $p^k$, $k > 1$,
assuming \kbd{p} is an odd prime.

\fun{long}{Zp_issquare}{GEN x, GEN p} returns 1 if the \typ{INT} $x$ is
a $p$-adic square, $0$ otherwise.

\fun{GEN}{pgener_Fp_local}{GEN p, GEN L}, \kbd{L} being a vector of
primes dividing $p - 1$, returns an integer $x$ which is a generator of the
$\ell$-Sylow of $\F_p^*$ for every $\ell$ in \kbd{L}. In other words,
$x^{(p-1)/\ell} \neq 1$ for all such $\ell$. In particular, returns
\kbd{pgener\_Fp(p)} if \kbd{L} contains all primes dividing $p - 1$.
It is not necessary, and in fact slightly inefficient, to include $\ell=2$,
since 2 is treated separately in any case, i.e. the generator
obtained is never a square.

\subsec{Miscellaneous functions}

\fun{void}{addumului}{ulong a, ulong b, GEN x} return $a + b|X|$.

\fun{long}{cgcd}{long x, long y} returns the GCD of \kbd{x} and \kbd{y}.

\fun{ulong}{ugcd}{ulong x, ulong y} returns the GCD of \kbd{x} and \kbd{y}.

\fun{long}{clcm}{long x, long y} returns the LCM of \kbd{x} and \kbd{y},
provided it fits into a \kbd{long}. Silently overflows otherwise.

\fun{long}{cbezout}{long a,long b, long *u,long *v}, returns the GCD
$d$ of \kbd{a} and \kbd{b} and sets \kbd{u}, \kbd{v} to the Bezout coefficients
such that $\kbd{au} + \kbd{bv} = d$.

\fun{GEN}{bezout}{GEN a,GEN b, GEN *u,GEN *v}, returns the GCD $d$ of
\typ{INT}s \kbd{a} and \kbd{b} and sets \kbd{u}, \kbd{v} to the Bezout
coefficients such that $\kbd{au} + \kbd{bv} = d$.

\fun{GEN}{factoru}{ulong n}, returns the factorization of $n$. The result
is a $2$-component vector $[P,E]$, where $P$ and $E$ are \typ{VECSMALL}
containing the prime divisors of $n$, and the $v_p(n)$.

\fun{ulong}{phiu}{ulong n}, Euler's totient function of $n$.

\fun{GEN}{divisorsu}{ulong n}, returns the divisors of $n$ in a
\typ{VECSMALL}, sorted by increasing order.

\fun{GEN}{factoru_pow}{ulong n}, returns the factorization of $n$. The result
is a $3$-component vector $[P,E,C]$, where $P$, $E$ and $C$ are
\typ{VECSMALL} containing the prime divisors of $n$, the $v_p(n)$
and the $p^{v_p(n)}$.

\fun{GEN}{factor_pn_1}{GEN p, long n} returns the factorization of $p^n-1$,
where $p$ and $n$ are positive integers.

\fun{GEN}{gcdii}{GEN x, GEN y}, returns the GCD of the \typ{INT}s \kbd{x} and
\kbd{y}.

\fun{GEN}{lcmii}{GEN x, GEN y}, returns the LCM of the \typ{INT}s \kbd{x} and
\kbd{y}.

\fun{long}{maxss}{long x, long y}, return the largest of \kbd{x} and \kbd{y}.

\fun{long}{minss}{long x, long y}, return the smallest of \kbd{x} and \kbd{y}.

\fun{GEN}{powuu}{ulong n, ulong k}, returns $n^k$.

\fun{GEN}{powiu}{GEN n, ulong k}, assumes $n$ is a \typ{INT} and returns $n^k$.

\fun{ulong}{upowuu}{ulong n, ulong k}, returns $n^k$ modulo $2^\B$. This is
meant to be used for tiny $k$, where in fact $n^k$ fits into an \kbd{ulong}.

\fun{GEN}{rdivii}{GEN x, GEN y, long prec}, assuming \kbd{x} and \kbd{y}
are both of type \typ{INT}, return the quotient x/y as a \typ{REAL} of
precision \kbd{prec}.

\fun{GEN}{rdivis}{GEN x, long y, long prec}, assuming \kbd{x}
is of type \typ{INT}, return the quotient x/y as a \typ{REAL} of
precision \kbd{prec}.

\fun{GEN}{rdivsi}{long x, GEN y, long prec}, assuming \kbd{y}
is of type \typ{INT}, return the quotient x/y as a \typ{REAL} of
precision \kbd{prec}.

\fun{GEN}{rdivss}{long x, long y, long prec}, return the quotient x/y as a
\typ{REAL} of precision \kbd{prec}.

\section{Level 2 kernel (modular arithmetic)}

\noindent These routines implement univariate polynomial arithmetic and
linear algebra over finite fields, in fact over finite rings of the form
$(\Z/p\Z)[X]/(T)$, where $p$ is not necessarily prime and $T\in(\Z/p\Z)[X]$ is
possibly reducible; and finite extensions thereof. All this can be emulated
with \typ{INTMOD} and \typ{POLMOD} coefficients and using generic routines,
at a considerable loss of efficiency. Also, specialized routines are
available that have no obvious generic equivalent.

\subsec{Naming scheme}. A function name is built in the following way:
$A_1\kbd{\_}\dots\kbd{\_}A_n\var{fun}$ for an operation \var{fun} with $n$
arguments of class $A_1$,\dots, $A_n$. A class name is given by a base ring
followed by a number of code letters. Base rings are among

  \kbd{Fl}: $\Z/l\Z$ where $l < 2^{\B}$ is not necessarily prime. Implemented
            using \kbd{ulong}s

  \kbd{Fp}: $\Z/p\Z$ where $p$ is a \typ{INT}, not necessarily prime.
Implemented as \typ{INT}s $z$, preferably satisfying $0 \leq z < p$.
More precisely, any \typ{INT} can be used as an \kbd{Fp}, but reduced
inputs are treated more efficiently. Outputs from \kbd{Fp}xxx routines are
reduced.

  \kbd{Fq}: $\Z[X]/(p,T(X))$, $p$ a \typ{INT}, $T$ a \typ{POL} with \kbd{Fp}
coefficients or \kbd{NULL} (in which case no reduction modulo \kbd{T} is
performed). Implemented as \typ{POL}s $z$ with \kbd{Fp} coefficients,
$\deg(z) < \deg \kbd{T}$.

  \kbd{Z}:  the integers $\Z$, implemented as \typ{INT}s.

  \kbd{z}:  the integers $\Z$, implemented using (signed) \kbd{long}s.

  \kbd{Q}:  the rational numbers $\Q$, implemented as \typ{INT}s and
\typ{FRAC}s.

  \kbd{Rg}:  a commutative ring, whose elements can be
\kbd{gadd}-ed, \kbd{gmul}-ed, etc.

\noindent Possible letters are:

  \kbd{X}: polynomial in $X$ (\typ{POL} in a fixed variable), e.g. \kbd{FpX}
           means $\Z/p\Z[X]$

  \kbd{Y}: polynomial in $Y\neq X$. This is used to resolve ambiguities.
           E.g. \kbd{FpXY} means $((\Z/p\Z)[X])[Y]$.

  \kbd{V}: vector (\typ{VEC} or \typ{COL}), treated as a line vector
  (independently of the actual type). E.g. \kbd{ZV} means $\Z^k$ for some $k$.

  \kbd{C}: vector (\typ{VEC} or \typ{COL}), treated as a column vector
  (independently of the actual type). The difference with \kbd{V} is purely
  semantic.

  \kbd{M}: matrix (\typ{MAT}). E.g. \kbd{QM} means a matrix with rational
  entries

  \kbd{Q}: representative (\typ{POL}) of a class in a polynomial quotient ring.
  E.g.~an \kbd{FpXQ} belongs to $(\Z/p\Z)[X]/(T(X))$, \kbd{FpXQV} means a
  vector of such elements, etc.

  \kbd{x}, \kbd{y}, \kbd{m}, \kbd{v}, \kbd{c}, \kbd{q}: as their uppercase
  counterpart, but coefficient arrays are implemented using \typ{VECSMALL}s,
  which coefficient understood as \kbd{ulong}s.

  \kbd{x} and \kbd{y} (and \kbd{q}) are implemented by a \typ{VECSMALL} whose
  first coefficient is used as a code-word and the following are the
  coefficients , similarly to a \typ{POL}. This is known as a 'POLSMALL'.

  \kbd{m} are implemented by a \typ{MAT} whose components (columns) are
  \typ{VECSMALL}s. This is know as a 'MATSMALL'.

  \kbd{v} and \kbd{c} are regular \typ{VECSMALL}s. Difference between the
  two is purely semantic.

\noindent Omitting the letter means the argument is a scalar in the base
ring. Standard functions \var{fun} are

  \kbd{add}: add

  \kbd{sub}: subtract

  \kbd{mul}: multiply

  \kbd{sqr}: square

  \kbd{div}: divide (Euclidean quotient)

  \kbd{rem}: Euclidean remainder

  \kbd{divrem}: return Euclidean quotient, store remainder in a pointer
argument.

  \kbd{gcd}: GCD

  \kbd{extgcd}: return GCD, store Bezout coefficients in pointer arguments

  \kbd{pow}: exponentiate

  \kbd{compo}: composition

\subsec{\kbd{ZX}, \kbd{ZV}, \kbd{ZM}}. A \kbd{ZV} (resp.~a~\kbd{ZM},
resp.~a~\kbd{ZX}) is a \typ{VEC} or \typ{COL} (resp.~\typ{MAT},
resp.~\typ{POL}) with \typ{INT} coefficients.

\subsubsec{\kbd{ZV}}

\fun{GEN}{ZV_add}{GEN x, GEN y} adds \kbd{x} and \kbd{y}.

\fun{GEN}{ZV_sub}{GEN x, GEN y} subtracts \kbd{x} and \kbd{y}.

\subsubsec{\kbd{ZM}}

\fun{GEN}{ZM_inv}{GEN M, GEN d} if \kbd{M} is a \kbd{ZM} and \kbd{d}
is a \typ{INT} such that $M' := \kbd{d}\kbd{M}^{-1}$ is integral,
return $M'$. It is allowed to set \kbd{d = NULL}, in which case, the
determinant of \kbd{M} is computed and used instead.

\fun{GEN}{QM_inv}{GEN M, GEN d} as above, with \kbd{M} a \kbd{QM}. We
still assume that $M'$ has integer coefficients.

\fun{int}{ZM_ishnf}{GEN x} return $1$ if $x$ is square upper triangular with
positive diagonal coefficients. Assumes $x$ is a \kbd{ZM} (has integer
coefficiets).

\fun{int}{RgM_ishnf}{GEN x} as \kbd{ZM\_ishnf}, without assumptions on the
types of the coefficients.

\subsubsec{\kbd{ZX}}

\fun{GEN}{ZX_renormalize}{GEN x, long l}, as \kbd{normalizepol}, where
$\kbd{l} = \kbd{lg(x)}$, in place.

\fun{GEN}{ZX_add}{GEN x,GEN y} adds \kbd{x} and \kbd{y}.

\fun{GEN}{ZX_sub}{GEN x,GEN y} subtracts \kbd{x} and \kbd{y}.

\fun{GEN}{ZX_neg}{GEN x,GEN p} returns $-\kbd{x}$.

\fun{GEN}{ZX_Z_add}{GEN x,GEN y} adds the integer \kbd{y} to the polynomial \kbd{x}.

\fun{GEN}{ZX_Z_mul}{GEN x,GEN y} multiplies the polynomial \kbd{x} by the integer \kbd{y}.

\fun{GEN}{ZX_mul}{GEN x,GEN y} multiplies \kbd{x} and \kbd{y}.

\fun{GEN}{ZX_sqr}{GEN x,GEN p} returns $\kbd{x}^2$.

\fun{GEN}{ZX_gcd}{GEN x,GEN y} returns a gcd of \kbd{x} and \kbd{y}.

\fun{GEN}{QX_gcd}{GEN x,GEN y} as \kbd{ZX\_gcd}.

\fun{GEN}{ZX_caract}{GEN T, GEN A, long v}: let \kbd{T} and \kbd{A} be
\kbd{ZX}s, returns the characteristic polynomial of \kbd{Mod(A, T)}.
More generally, \kbd{A} is allowed to be a \kbd{QX}, hence possibly has
rational coefficients, \emph{assuming} the result is a \kbd{ZX}, i.e.~the
algebraic number \kbd{Mod(A,T)} is integral over \kbd{Z}.

\fun{GEN}{ZX_deriv}{GEN x} returns the derivative of \kbd{x}.

\fun{GEN}{ZX_disc}{GEN T} returns the discriminant of the \kbd{ZX}
\kbd{T}.

\fun{int}{ZX_is_squarefree}{GEN T} returns $1$ if the
\kbd{ZX}~\kbd{T} is squarefree, $0$ otherwise.

\fun{GEN}{ZX_factor}{GEN T} returns the factorization of the primitive part
of \kbd{T} over $\Q[X]$ (the content is lost).

\fun{GEN}{QX_factor}{GEN T} as \kbd{ZX\_factor}.

\fun{GEN}{ZX_resultant}{GEN A, GEN B} returns the resultant of the
\kbd{ZX}~\kbd{A} and \kbd{B}.

\fun{GEN}{ZX_QX_resultant}{GEN A, GEN B} returns the resultant of the
\kbd{ZX}~\kbd{A} and the \kbd{QX}~\kbd{B}, \emph{assuming} the result
is an integer.

\fun{GEN}{ZX_ZXY_resultant}{GEN A, GEN B}
under the assumption that \kbd{A} in $\Z[Y]$, \kbd{B} in $\Q[Y][X]$, and
$R = \text{Res}_Y(A, B) \in \Z[X]$, returns the resultant $R$.

\fun{GEN}{ZX_ZXY_rnfequation}{GEN A, GEN B, long *lambda},
assume \kbd{A} in $\Z[Y]$, \kbd{B} in $\Q[Y][X]$, and $R =
\text{Res}_Y(A, B) \in \Z[X]$. If \kbd{lambda = NULL}, returns $R$
as in \kbd{ZY\_ZXY\_resultant}. Otherwise, \kbd{lambda} must point to
some integer, e.g. $0$ which is used as a seed. The function then finds a
small $\lambda \in \Z$ (starting from \kbd{*lambda}) such that
$R_\lambda(X) := \text{Res}_Y(A, B(X + \lambda Y))$ is squarefree, resets
\kbd{*lambda} to the chosen value and returns $R_{\lambda}$.

\subsec{\kbd{FpX}}. Let \kbd{p} an understood \typ{INT}, to be given in
the function arguments; in practice \kbd{p} is not assumed to be prime, but
be wary. An \kbd{Fp} object is a \typ{INT} belonging to $[0,
\kbd{p}-1]$, an \kbd{FpX} is a \typ{POL} in a fixed variable whose
coefficients are \kbd{Fp} objects. Unless mentioned otherwise, all outputs
in this section are \kbd{FpX}s. All operations are understood to take place
in $(\Z/\kbd{p}\Z)[X]$.

\subsubsec{Basic operations}. In what follows \kbd{p} is always a \typ{INT},
not necessarily prime.

\fun{GEN}{Rg_to_Fp}{GEN z, GEN p}, \kbd{z} a scalar which can be mapped to
$\Z/p\Z$: a \typ{INT}, a \typ{INTMOD} whose modulus is divisible by $p$,
a \typ{FRAC} whose denominator is coprime to $p$, or a \typ{PADIC} with
underlying prime $p$. Returns \kbd{lift(z * Mod(1,p))}, normalized.

\fun{GEN}{RgX_to_FpX}{GEN z, GEN p}, \kbd{z} a \typ{POL}, returns the
\kbd{FpX} obtained by applying \kbd{Rg\_to\_Fp} coefficientwise.

\fun{GEN}{RgV_to_FpV}{GEN z, GEN p}, \kbd{z} a \typ{VEC} or \typ{COL},
returns the \kbd{FpV} (as a \typ{VEC}) obtained by applying \kbd{Rg\_to\_Fp}
coefficientwise.

\fun{GEN}{RgC_to_FpC}{GEN z, GEN p}, \kbd{z} a \typ{VEC} or \typ{COL},
returns the \kbd{FpC} (as a \typ{COL}) obtained by applying \kbd{Rg\_to\_Fp}
coefficientwise.

\fun{GEN}{FpX_to_mod}{GEN z, GEN p}, \kbd{z} a \kbd{ZX}. Returns \kbd{z *
Mod(1,p)}, normalized. Hence the returned value has \typ{INTMOD}
coefficients.

\fun{GEN}{FpX_red}{GEN z, GEN p}, \kbd{z} a \kbd{ZX}, returns \kbd{lift(z *
Mod(1,p))}, normalized.

\fun{GEN}{FpXV_red}{GEN z, GEN p}, \kbd{z} a \typ{VEC} of \kbd{ZX}. Applies
\kbd{FpX\_red} componentwise and returns the result (and we obtain a vector
of \kbd{FpX}s).

\noindent Now, except for \kbd{p}, the operands and outputs are all \kbd{FpX}
objects. Results are undefined on other inputs.

\fun{GEN}{FpX_add}{GEN x,GEN y, GEN p} adds \kbd{x} and \kbd{y}.

\fun{GEN}{FpX_neg}{GEN x,GEN p} returns $-\kbd{x}$, the components are 
between $0$ and $p$ if this is the case for the components of $x$.

\fun{GEN}{FpX_renormalize}{GEN x, long l}, as \kbd{normalizepol}, where
$\kbd{l} = \kbd{lg(x)}$, in place.

\fun{GEN}{FpX_sub}{GEN x,GEN y,GEN p} subtracts \kbd{y} from \kbd{x}.

\fun{GEN}{FpX_mul}{GEN x,GEN y,GEN p} multiplies \kbd{x} and \kbd{y}.

\fun{GEN}{FpX_sqr}{GEN x,GEN p} returns $\kbd{x}^2$.

\fun{GEN}{FpX_divrem}{GEN x, GEN y, GEN p, GEN *pr} returns the quotient
of \kbd{x} by \kbd{y}, and sets \kbd{pr} to the remainder.

\fun{GEN}{FpX_div}{GEN x, GEN y, GEN p} returns the quotient of \kbd{x} by
\kbd{y}.

\fun{GEN}{FpX_div_by_X_x}{GEN A, GEN a, GEN p, GEN *r} returns the
quotient of the \kbd{FpX}~\kbd{A} by $(X - \kbd{a})$, and sets \kbd{r} to the
remainder $\kbd{A}(\kbd{a})$.

\fun{GEN}{FpX_rem}{GEN x, GEN y, GEN p} returns the remainder \kbd{x} mod
\kbd{y}.

\fun{long}{FpX_valrem}{GEN x, GEN t, GEN p, GEN *r} The arguments \kbd{x} and
\kbd{e} being non-zero \kbd{FpX} returns the highest exponent $e$ such that
$\kbd{t}^{e}$ divides~\kbd{x}. The quotient $\kbd{x}/\kbd{t}^{e}$ is returned
in~\kbd{*r}. In particular, if \kbd{t} is irreducible, this returns the
valuation at \kbd{t} of~\kbd{x}, and \kbd{*r} is the prime-to-\kbd{t} part
of~\kbd{x}.

\fun{GEN}{FpX_gcd}{GEN x, GEN y, GEN p} returns a (not necessarily monic)
greatest common divisor of $x$  and $y$.

\fun{GEN}{FpX_deriv}{GEN x, GEN p} returns the derivative of \kbd{x}.
This function is not memory-clean, but nevertheless suitable for
\kbd{gerepileupto}.

\fun{GEN}{FpX_extgcd}{GEN x, GEN y, GEN p, GEN *u, GEN *v} returns
$d = \text{GCD}(\kbd{x},\kbd{y})$, and sets \kbd{*u}, \kbd{*v} to the Bezout
coefficients such that $\kbd{*ux} + \kbd{*vy} = d$.

\fun{GEN}{FpX_center}{GEN z, GEN p} returns the polynomial whose coefficient
belong to the symmetric residue system (clean version of \kbd{centermod},
which assumes the coefficients already belong to $[0,\kbd{p}-1]$).

\subsubsec{Miscellaneous operations}

\fun{GEN}{FpX_normalize}{GEN z, GEN p} divides the \kbd{FpX}~\kbd{z} by its
leading coefficient. If the latter is~$1$, \kbd{z} itself is returned, not a
copy. If not, the inverse remains uncollected on the stack.


\fun{GEN}{FpX_Fp_add}{GEN y, GEN x, GEN p} add the \kbd{Fp}~\kbd{x} to the
\kbd{FpX}~\kbd{y}.

\fun{GEN}{FpX_Fp_add_shallow}{GEN y, GEN x, GEN p} add the \kbd{Fp}~\kbd{x}
to the \kbd{FpX}~\kbd{y}, using a shallow copy (result not suitable for
\kbd{gerepileupto})

\fun{GEN}{FpX_Fp_mul}{GEN y, GEN x, GEN p} multiplies the \kbd{FpX}~\kbd{y}
by the \kbd{Fp}~\kbd{x}.

\fun{GEN}{FpX_rescale}{GEN P, GEN h, GEN p} returns $h^{\deg(P)} P(x/h)$.
\kbd{P} is an \kbd{FpX} and \kbd{h} is a non-zero \kbd{Fp} (the routine would
work with any non-zero \typ{INT} but is not efficient in this case).

\fun{GEN}{FpX_eval}{GEN x, GEN y, GEN p} evaluates the \kbd{FpX}~\kbd{x}
at the \kbd{Fp}~\kbd{y}. The result is an~\kbd{Fp}.

\fun{GEN}{FpXV_FpC_mul}{GEN V, GEN W, GEN p} multiplies a line vector
of\kbd{FpX} by a column vector of \kbd{Fp} (scalar product). The result is
an~\kbd{FpX}.

\fun{GEN}{FpXV_prod}{GEN V, GEN p}, \kbd{V} being a vector of \kbd{FpX},
returns their product.

\fun{GEN}{FpV_roots_to_pol}{GEN V, GEN p, long v}, \kbd{V} being a vector
of \kbd{INT}s, returns the monic \kbd{FpX}
$\prod_i (\kbd{pol\_x[v]} - \kbd{V[i]})$.

\fun{GEN}{FpX_chinese_coprime}{GEN x,GEN y, GEN Tx,GEN Ty, GEN Tz, GEN p}:
returns an \kbd{FpX}, congruent to \kbd{x} mod \kbd{Tx} and to \kbd{y} mod
\kbd{Ty}. Assumes \kbd{Tx} and \kbd{Ty} are coprime, and \kbd{Tz = Tx * Ty}
or \kbd{NULL} (in which case it is computed within).

\fun{GEN}{FpV_polint}{GEN x, GEN y, GEN p} returns the \kbd{FpX}
interpolation polynomial with value \kbd{y[i]} at \kbd{x[i]}. Assumes lengths
are the same, components are \typ{INT}s, and the \kbd{x[i]} are distinct
modulo \kbd{p}.

\fun{long}{FpX_is_squarefree}{GEN f, GEN p} returns $1$ if the
\kbd{FpX}~\kbd{f} is squarefree, $0$ otherwise.

\fun{long}{FpX_is_irred}{GEN f, GEN p} returns $1$ if the \kbd{FpX}~\kbd{f}
is irreducible, $0$ otherwise. Assumes that \kbd{p} is prime. If~\kbd{f} has
few factors, \kbd{FpX\_nbfact(f,p) == 1} is much faster.

\fun{long}{FpX_is_totally_split}{GEN f, GEN p} returns $1$ if the
\kbd{FpX}~\kbd{f} splits into a product of distinct linear factors, $0$
otherwise. Assumes that \kbd{p} is prime.

\fun{GEN}{FpX_factor}{GEN f, GEN p}, factors the \kbd{FpX}~\kbd{f}. Assumes
that \kbd{p} is prime. The returned value \kbd{v} has two components:
\kbd{v[1]} is a vector of distinct irreducible (\kbd{FpX}) factors, and
\kbd{v[2]} is a \typ{VECSMALL} of corresponding exponents. The order
of the factors is deterministic (the computation is not).

\fun{long}{FpX_nbfact}{GEN f, GEN p}, assuming the \kbd{FpX}~f is squarefree,
returns the number of its irreducible factors. Assumes that \kbd{p} is prime.

\fun{long}{FpX_degfact}{GEN f, GEN p}, as \kbd{FpX\_factor}, but the
degrees of the irreducible factors are returned instead of the factors
themselves (as a \typ{VECSMALL}). Assumes that \kbd{p} is prime.

\fun{long}{FpX_nbroots}{GEN f, GEN p} returns the number of distinct
roots in \kbd{\Z/p\Z} of the \kbd{FpX}~\kbd{f}. Assumes that \kbd{p} is prime.

\fun{GEN}{FpX_roots}{GEN f, GEN p} returns the roots in \kbd{\Z/p\Z} of
the \kbd{FpX}~\kbd{f} (without multiplicity, as a vector of \kbd{Fp}s).
Assumes that \kbd{p} is prime.

\fun{GEN}{random_FpX}{long d, long v, GEN p} returns a random \kbd{FpX}
in variable \kbd{v}, of degree less than~\kbd{d}.

\fun{GEN}{FpX_resultant}{GEN x, GEN y, GEN p} returns the resultant
of \kbd{x} and \kbd{y}, both \kbd{FpX}. The result is a \typ{INT}
belonging to $[0,p-1]$.

\fun{GEN}{FpX_FpXY_resultant}{GEN a, GEN b, GEN p}, \kbd{a} a \typ{POL} of
\typ{INT}s (say in variable $X$), \kbd{b} a \typ{POL} (say in variable $X$)
whose coefficients are either \typ{POL}s in $\Z[Y]$ or \typ{INT}s.
Returns $\text{Res}_X(a, b)$ in $\F_p[Y]$ as an \kbd{FpY}. The function
assumes that $X$ has lower priority than $Y$.

\subsec{\kbd{FpXQ}, \kbd{Fq}}. Let \kbd{p} a \typ{INT} and \kbd{T} an
\kbd{FpX} for \kbd{p}, both to be given in the function arguments; an \kbd{FpXQ}
object is an \kbd{FpX} whose degree is strictly less than the degree of
\kbd{T}. An \kbd{Fq} is either an \kbd{FpXQ} or an \kbd{Fp}. Both represent
a class in $(\Z/\kbd{p}\Z)[X] / (T)$, in which all operations below take
place. In addition, \kbd{Fq} routines also allow $\kbd{T} = \kbd{NULL}$, in
which case no reduction mod \kbd{T} is performed on the result.

For efficiency, the routines in this section may leave small unused objects
behind on the stack (their output is still suitable for \kbd{gerepileupto}).
Besides \kbd{T} and \kbd{p}, arguments are either \kbd{FpXQ} or \kbd{Fq}
depending on the function name. (All \kbd{Fq} routines accept \kbd{FpXQ}s by
definition, not the other way round.)

\fun{GEN}{Rg_to_FpXQ}{GEN z, GEN T, GEN p}, \kbd{z} a \kbd{GEN} which can be
mapped to $\F_p[X]/(T)$: anything \kbd{Rg\_to\_Fp} can be applied to,
a \typ{POL} to which \kbd{RgX\_to\_FpX} can be applied to, a \typ{POLMOD}
whose modulus is divisible by $T$ (once mapped to a \kbd{FpX}), a suitable
\typ{RFRAC}. Returns \kbd{z} as an \kbd{FpXQ}, normalized.

\fun{GEN}{RgX_to_FpXQX}{GEN z, GEN T, GEN p}, \kbd{z} a \typ{POL}, returns the
\kbd{FpXQ} obtained by applying \kbd{Rg\_to\_FpXQ} coefficientwise.

\fun{GEN}{RgX_to_FqX}{GEN z, GEN T, GEN p}: let \kbd{z} be a \typ{POL};
returns the \kbd{FpXQ} obtained by applying \kbd{Rg\_to\_FpXQ}
coefficientwise and simplifying scalars to \typ{INT}s.

\fun{GEN}{Fq_red}{GEN x, GEN T, GEN p}, \kbd{x} a \kbd{ZX} or \typ{INT},
reduce it to an \kbd{Fq} ($\kbd{T} = \kbd{NULL}$ is allowed iff \kbd{x} is a
\typ{INT}).

\fun{GEN}{FqX_red}{GEN x, GEN T, GEN p}, \kbd{x} a \typ{POL}
whose coefficients are \kbd{ZX}s or \typ{INT}s, reduce them to \kbd{Fq}s. (If
$\kbd{T} = \kbd{NULL}$, as \kbd{FpXX\_red(x, p)}.)

\fun{GEN}{FqV_red}{GEN x, GEN T, GEN p}, \kbd{x} a vector of \kbd{ZX}s or
\typ{INT}s, reduce them to \kbd{Fq}s. (If $\kbd{T} = \kbd{NULL}$, only
reduce components mod \kbd{p} to \kbd{FpX}s or \kbd{Fp}s.)

\fun{GEN}{FpXQ_mul}{GEN y, GEN x, GEN T,GEN p}

\fun{GEN}{FpXQ_sqr}{GEN y, GEN T, GEN p}

\fun{GEN}{FpXQ_div}{GEN x, GEN y, GEN T,GEN p}

\fun{GEN}{FpXQ_inv}{GEN x, GEN T, GEN p} computes the inverse of \kbd{x}

\fun{GEN}{FpXQ_invsafe}{GEN x,GEN T,GEN p}, as \kbd{FpXQ\_inv}, returning
\kbd{NULL} if \kbd{x} is not invertible.

\fun{GEN}{FpXQ_pow}{GEN x, GEN n, GEN T, GEN p} computes $\kbd{x}^\kbd{n}$.

\fun{GEN}{FpXQ_log}{GEN a, GEN g, GEN ord, GEN T, GEN p} Let \kbd{g} be of
order \kbd{ord} in the finite field $\F_p[X]/(T)$. Return $e$ such that
$a^e=g$. If $e$ does not exists, the result is currently undefined.

\fun{GEN}{Fp_FpXQ_log}{GEN a, GEN g, GEN ord, GEN T, GEN p} As
\kbd{FpXQ\_log}, \kbd{a} being a \kbd{Fp}.

\fun{GEN}{FpXQ_order}{GEN a, GEN ord, GEN T, GEN p} returns the order of the
\typ{FpXQ} \kbd{a}. If \kbd{o} is non-\kbd{NULL}, it is assumed that \kbd{o}
is a multiple of the order of \kbd{a}, either as a \typ{INT} or a
factorization matrix.

\fun{GEN}{FpXQ_sqrtn}{GEN x, GEN n, GEN T, GEN p, GEN *zn} returns an
\kbd{n}-th root of $\kbd{x}$.  Return \kbd{NULL} if \kbd{x} is not an
\kbd{n}-th power residue. Otherwise, if \kbd{zn} is non-\kbd{NULL} set it to a
primitive \kbd{n}-th root of the unity.

\fun{GEN}{Fq_add}{GEN x, GEN y, GEN T/*unused*/, GEN p}

\fun{GEN}{Fq_sub}{GEN x, GEN y, GEN T/*unused*/, GEN p}

\fun{GEN}{Fq_mul}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{Fq_neg}{GEN x, GEN T, GEN p}

\fun{GEN}{Fq_neg_inv}{GEN x, GEN T, GEN p} computes $-\kbd{x}^{-1}$

\fun{GEN}{Fq_inv}{GEN x, GEN pol, GEN p} computes $\kbd{x}^{-1}$, raising an
error if \kbd{x} is not invertible.

\fun{GEN}{Fq_invsafe}{GEN x, GEN pol, GEN p} as \kbd{Fq\_inv}, but returns
\kbd{NULL} if \kbd{x} is not invertible.

\fun{GEN}{Fq_pow}{GEN x, GEN n, GEN pol, GEN p} returns $\kbd{x}^\kbd{n}$.

\fun{GEN}{FpXQ_charpoly}{GEN x, GEN T, GEN p} returns the characteristic
polynomial of \kbd{x}

\fun{GEN}{FpXQ_minpoly}{GEN x, GEN T, GEN p} returns the minimal polynomial
of \kbd{x}

\fun{GEN}{FpXQ_norm}{GEN x, GEN T, GEN p} returns the norm of \kbd{x}

\fun{GEN}{gener_FpXQ}{GEN T, GEN p} returns a primitive root modulo
$(T,p)$. $T$ is an \kbd{FpX} assumed to be irreducible modulo the prime
$p$.

\fun{GEN}{FpXQ_powers}{GEN x, long n, GEN T, GEN p} returns $[\kbd{x}^0,
\dots, \kbd{x}^\kbd{n}]$ as a \typ{VEC} of \kbd{FpXQ}s.

\fun{GEN}{FpXQ_matrix_pow}{GEN x, long m, long n, GEN T, GEN p}, as
\kbd{FpXQ\_powers}$(x, n-1, T, p)$, but returns the powers as a an
$m\times n$ matrix. Usually, we have $m = n = \deg T$.

\fun{GEN}{FpX_FpXQ_compo}{GEN f,GEN x,GEN T,GEN p} returns
$\kbd{f}(\kbd{x})$.

\fun{GEN}{FpX_FpXQV_compo}{GEN f,GEN V,GEN T,GEN p} returns
$\kbd{f}(\kbd{x})$, assuming that \kbd{V} was computed by
$\kbd{FpXQ\_powers}(\kbd{x}, n, \kbd{T}, \kbd{p})$.

\subsec{\kbd{FpXX}}.
Contrary to what the name implies, an \kbd{FpXQX} is a \typ{POL} whose
coefficients are either \typ{INT}s or \typ{FpX}s. This reduce memory
overhead at the expense of consistency.

\fun{GEN}{FpXX_add}{GEN x, GEN y, GEN p} adds \kbd{x} and \kbd{y}.

\fun{GEN}{FpXX_red}{GEN z, GEN p}, \kbd{z} a \typ{POL} whose coefficients are
either \kbd{ZX}s or \typ{INT}s. Returns the \typ{POL} equal to \kbd{z} with
all components reduced modulo \kbd{p}.

\fun{GEN}{FpXX_renormalize}{GEN x, long l}, as \kbd{normalizepol}, where
$\kbd{l} = \kbd{lg(x)}$, in place.

\subsec{\kbd{FpXQX}, \kbd{FqX}}.
Contrary to what the name implies, an \kbd{FpXQX} is a \typ{POL} whose
coefficients are \kbd{Fq}s. So the only difference between \kbd{FqX} and
\kbd{FpXQX} routines is that $\kbd{T} = \kbd{NULL}$ is not allowed in the
latter. (It was thought more useful to allow \typ{INT} components than to
enforce strict consistency, which would not imply any efficiency gain.)

\subsubsec{Basic operations}

\fun{GEN}{FqX_mul}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{FqX_Fq_mul}{GEN P, GEN U, GEN T, GEN p} multiplies the
\kbd{FqX}~\kbd{y} by the \kbd{Fq}~\kbd{x}.

\fun{GEN}{FqX_normalize}{GEN z, GEN T, GEN p} divides the \kbd{FqX}~\kbd{z}
by its leading term.

\fun{GEN}{FqX_sqr}{GEN x, GEN T, GEN p}

\fun{GEN}{FqX_divrem}{GEN x, GEN y, GEN T, GEN p, GEN *z}

\fun{GEN}{FqX_div}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{FqX_rem}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{FqX_deriv}{GEN x, GEN T, GEN p} returns the derivative of \kbd{x}.
(This function is suitable for \kbd{gerepilupto} but not memory-clean.)

\fun{GEN}{FqX_gcd}{GEN P, GEN Q, GEN T, GEN p}

\fun{GEN}{FqX_eval}{GEN x, GEN y, GEN T, GEN p} evaluates the \kbd{FqX}~\kbd{x}
at the \kbd{Fq}~\kbd{y}. The result is an~\kbd{Fq}.

\fun{GEN}{FpXQX_red}{GEN z, GEN T, GEN p} \kbd{z} a \typ{POL} whose
coefficients are \kbd{ZX}s or \typ{INT}s, reduce them to \kbd{FpXQ}s.

\fun{GEN}{FpXQX_mul}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{FpXQX_sqr}{GEN x, GEN T, GEN p}

\fun{GEN}{FpXQX_divrem}{GEN x, GEN y, GEN T, GEN p, GEN *pr}

\fun{GEN}{FpXQX_gcd}{GEN x, GEN y, GEN T, GEN p}

\fun{GEN}{FpXQX_extgcd}{GEN x, GEN y, GEN T, GEN p, GEN *ptu, GEN *ptv}

\fun{GEN}{FpXQYQ_pow}{GEN x, GEN n, GEN S, GEN T, GEN p}, \kbd{x} and
\kbd{T} being \kbd{FpXQX}s, returns $\kbd{x}^\kbd{n}$ modulo \kbd{S}.

\fun{GEN}{FpXQXV_prod}{GEN V, GEN T, GEN p}, \kbd{V} being a vector of
\kbd{FpXQX}, returns their product.

\fun{GEN}{FqV_roots_to_pol}{GEN V, GEN T, GEN p, long v},
\kbd{V} being a vector of \kbd{Fq}s, returns the monic \kbd{FqX}
$\prod_i (\kbd{pol\_x[v]} - \kbd{V[i]})$.

\subsubsec{Miscellaneous operations}

\fun{GEN}{init_Fq}{GEN p, long n, long v} returns an irreducible polynomial
of degree \kbd{n} over $\F_p$, in variable \kbd{v}.

\fun{long}{FqX_is_squarefree}{GEN P, GEN T, GEN p}

\fun{GEN}{FqX_factor}{GEN x, GEN T, GEN p} same output convention as
\kbd{FpX\_factor}. Assumes \kbd{p} is prime and \kbd{T} irreducible
in $\F_p[X]$.

\fun{GEN}{FpX_factorff_irred}{GEN P, GEN T, GEN p}. Assumes \kbd{p} prime
and \kbd{T} irreducible in $\F_p[X]$. \kbd{P} being an \emph{irreducible}
\kbd{FpX}, factors it over the finite field $\F_p[Y]/(T(Y))$ and returns the
vector of irreducible \kbd{FqX}s factors (the exponents, being all equal to
$1$, are not included).

\fun{GEN}{FpX_ffisom}{GEN P, GEN Q, GEN p}. Assumes \kbd{p} prime,
\kbd{P}, \kbd{Q} are \kbd{ZX}s, both irreducible mod \kbd{p}, and
$\deg(P) \mid \deg Q$. Outputs a monomorphism between $\F_p[X]/(P)$ and
$\F_p[X]/(Q)$, as a polynomial $R$ such that $\kbd{Q} \mid \kbd{P}(R)$ in
$\F_p[X]$. If \kbd{P} and \kbd{Q} have the same degree, it is of course an
isomorphism.

\fun{void}{FpX_ffintersect}{GEN P, GEN Q, long n, GEN p, GEN *SP,GEN *SQ, GEN
MA,GEN MB}\hfil\break
Assumes \kbd{p} is prime, \kbd{P}, \kbd{Q} are \kbd{ZX}s, both
irreducible mod \kbd{p}, and \kbd{n} divides both the degree of \kbd{P} and
\kbd{Q}. Compute \kbd{SP} and \kbd{SQ} such that the subfield of
$\F_p[X]/(P)$ generated by \kbd{SP} and the subfield of $\F_p[X]/(Q)$
generated by \kbd{SQ} are isomorphic of degree \kbd{n}. The polynomials
\kbd{P} and \kbd{Q} do not need to be of the same variable. If \kbd{MA}
(resp. \kbd{MB}) is not \kbd{NULL}, it must be the matrix of the Frobenius
map in $\F_p[X]/(P)$ (resp.~$\F_p[X]/(Q)$).

\fun{GEN}{FpXQ_ffisom_inv}{GEN S, GEN T, GEN p}. Assumes \kbd{p} is prime,
\kbd{T} a \kbd{ZX}, which is irreducible modulo \kbd{p}, \kbd{S} a
\kbd{ZX} representing an automorphism of $\F_q := \F_p[X]/(\kbd{T})$.
($\kbd{S}(X)$ is the image of $X$ by the automorphism.) Returns the
inverse automorphism of \kbd{S}, in the same format, i.e.~an \kbd{FpX}~$H$
such that $H(\kbd{S}) \equiv X$ modulo $(\kbd{T}, \kbd{p})$.

\fun{long}{FqX_nbfact}{GEN u, GEN T, GEN p}.
Assumes \kbd{p} is prime and \kbd{T} irreducible in $\F_p[X]$.

\fun{long}{FqX_nbroots}{GEN f, GEN T, GEN p}
Assumes \kbd{p} is prime and \kbd{T} irreducible in $\F_p[X]$.


\subsec{\kbd{FpV}, \kbd{FpM}, \kbd{FqM}}. A \kbd{ZV} (resp.~a~\kbd{ZM}) is a
\typ{VEC} or \typ{COL} (resp.~\typ{MAT}) with \typ{INT} coefficients. An
\kbd{FpV} or \kbd{FpM}, with respect to a given \typ{INT}~\kbd{p}, is the
same with \kbd{Fp} coordinates; operations are understood over $\Z/p\Z$. An
\kbd{FqM} is a matrix with \kbd{Fq} coefficients (with respect to given
\kbd{T}, \kbd{p}), not necessarily reduced (i.e arbitrary \typ{INT}s and
\kbd{ZX}s in the same variable as \kbd{T}).

\subsubsec{Basic operations}

\fun{GEN}{FpC_to_mod}{GEN z, GEN p}, \kbd{z} a \kbd{ZC}. Returns \kbd{Col(z) *
Mod(1,p)}, a \typ{COL} with \typ{INTMOD} coefficients.

\fun{GEN}{FpV_to_mod}{GEN z, GEN p}, \kbd{z} a \kbd{ZV}. Returns \kbd{Vec(z) *
Mod(1,p)}, a \typ{VEC} with \typ{INTMOD} coefficients.

\fun{GEN}{FpM_to_mod}{GEN z, GEN p}, \kbd{z} a \kbd{ZM}. Returns \kbd{z *
Mod(1,p)}, with \typ{INTMOD} coefficients.

\fun{GEN}{FpC_red}{GEN z, GEN p}, \kbd{z} a \kbd{ZC}. Returns \kbd{lift(Col(z) *
Mod(1,p))}, hence a \typ{COL}.

\fun{GEN}{FpV_red}{GEN z, GEN p}, \kbd{z} a \kbd{ZV}. Returns \kbd{lift(Vec(z) *
Mod(1,p))}, hence a \typ{VEC}

\fun{GEN}{FpM_red}{GEN z, GEN p}, \kbd{z} a \kbd{ZM}. Returns \kbd{lift(z *
Mod(1,p))}, which is an \kbd{FpM}.

\fun{GEN}{FpC_Fp_mul}{GEN x, GEN y, GEN p} multiplies the \kbd{ZC}~\kbd{x}
(seen as a column vector) by the \typ{INT}~\kbd{y} and reduce modulo \kbd{p} to
obtain an \kbd{FpC}.

\fun{GEN}{FpC_FpV_mul}{GEN x, GEN y, GEN p} multiplies the \kbd{ZC}~\kbd{x}
(seen as a column vector) by the \kbd{ZV}~\kbd{y} (seen as a row vector,
assumed to have compatible dimensions), and reduce modulo \kbd{p} to obtain
an \kbd{FpM}.

\fun{GEN}{FpM_mul}{GEN x, GEN y, GEN p} multiplies the two \kbd{ZM}s~\kbd{x}
and \kbd{y} (assumed to have compatible dimensions), and reduce modulo
\kbd{p} to obtain an \kbd{FpM}.

\fun{GEN}{FpM_FpC_mul}{GEN x, GEN y, GEN p} multiplies the \kbd{ZM}~\kbd{x}
by the \kbd{ZC}~\kbd{y} (seen as a column vector, assumed to have compatible
dimensions), and reduce modulo \kbd{p} to obtain an \kbd{FpC}.

\fun{GEN}{FpV_FpC_mul}{GEN x, GEN y, GEN p} multiplies the \kbd{ZV}~\kbd{x}
(seen as a row vector) by the \kbd{ZC}~\kbd{y} (seen as a column vector,
assumed to have compatible dimensions), and reduce modulo \kbd{p} to obtain
an \kbd{Fp}.

\fun{GEN}{FpV_dotproduct}{GEN x,GEN y,GEN p} scalar product of
$x$ and $y$.

\fun{GEN}{FpV_dotsquare}{GEN x, GEN p} scalar product of $x$ with itself.
has \typ{INT} entries.

\subsubsec{\kbd{Fp}-linear algebra}. The implementations are not
asymptotically efficient ($O(n^3)$ standard algorithms).

\fun{GEN}{FpM_deplin}{GEN x, GEN p} returns a non-trivial kernel vector,
or \kbd{NULL} if none exist.

\fun{GEN}{FpM_gauss}{GEN a, GEN b, GEN p} as \kbd{gauss}

\fun{GEN}{FpM_image}{GEN x, GEN p} as \kbd{image}

\fun{GEN}{FpM_intersect}{GEN x, GEN y, GEN p} as \kbd{intersect}

\fun{GEN}{FpM_inv}{GEN x, GEN p} returns the inverse of \kbd{x}, or
\kbd{NULL} if \kbd{x} is not invertible.

\fun{GEN}{FpM_invimage}{GEN m, GEN v, GEN p} as \kbd{inverseimage}

\fun{GEN}{FpM_ker}{GEN x, GEN p} as \kbd{ker}

\fun{long}{FpM_rank}{GEN x, GEN p} as \kbd{rank}

\fun{GEN}{FpM_indexrank}{GEN x, GEN p} as \kbd{indexrank} but returns a
\typ{VECSMALL}

\fun{GEN}{FpM_suppl}{GEN x, GEN p} as \kbd{suppl}

\subsubsec{\kbd{Fq}-linear algebra}

\fun{GEN}{FqM_gauss}{GEN a, GEN b, GEN T, GEN p} as \kbd{gauss}

\fun{GEN}{FqM_ker}{GEN x, GEN T, GEN p} as \kbd{ker}

\fun{GEN}{FqM_suppl}{GEN x, GEN T, GEN p} as \kbd{suppl}

\subsec{\kbd{Flx}} Let \kbd{p} an understood \kbd{ulong}, assumed to be
prime, to be given the the function arguments; an \kbd{Fl} is an \kbd{ulong}
belonging to $[0,\kbd{p}-1]$, an \kbd{Flx}~\kbd{z} is a \typ{VECSMALL}
representing a polynomial with small integer coefficients. Specifically
\kbd{z[0]} is the usual codeword, \kbd{z[1] = evalvarn($v$)} for some
variable $v$, then the coefficients by increasing degree. An \kbd{FlxX} is a
\typ{POL} whose coefficients are \kbd{Flx}s.

\noindent In the following, an argument called \kbd{sv} is of the form
\kbd{evalvarn}$(v)$ for some variable number~$v$.

\subsubsec{Basic operations}

\fun{ulong}{Rg_to_Fl}{GEN z, ulong p}, \kbd{z} which can be mapped to
$\Z/p\Z$: a \typ{INT}, a \typ{INTMOD} whose modulus is divisible by $p$,
a \typ{FRAC} whose denominator is coprime to $p$, or a \typ{PADIC} with
underlying prime $p$. Returns \kbd{lift(z * Mod(1,p))}, normalized, as an
\kbd{Fl}.

\fun{GEN}{Flx_red}{GEN z, ulong p} converts from \kbd{zx} with
non-negative coefficients to \kbd{Flx} (by reducing them mod \kbd{p}).

\fun{GEN}{Flx_add}{GEN x, GEN y, ulong p}

\fun{GEN}{Flx_Fl_add}{GEN y, ulong x, ulong p}

\fun{GEN}{Flx_neg}{GEN x, ulong p}

\fun{GEN}{Flx_neg_inplace}{GEN x, ulong p}, same as \kbd{Flx\_neg}, in place
(\kbd{x} is destroyed).

\fun{GEN}{Flx_sub}{GEN x, GEN y, ulong p}

\fun{GEN}{Flx_mul}{GEN x, GEN y, ulong p}

\fun{GEN}{Flx_Fl_mul}{GEN y, ulong x, ulong p}

\fun{GEN}{Flx_sqr}{GEN x, ulong p}

\fun{GEN}{Flx_divrem}{GEN x, GEN y, ulong p, GEN *pr}

\fun{GEN}{Flx_div}{GEN x, GEN y, ulong p}

\fun{GEN}{Flx_rem}{GEN x, GEN y, ulong p}

\fun{GEN}{Flx_deriv}{GEN z, ulong p}

\fun{GEN}{Flx_gcd}{GEN a, GEN b, ulong p} returns a (not necessarily monic)
greatest common divisor of $x$  and $y$.

\fun{GEN}{Flx_gcd_i}{GEN a, GEN b, ulong p}, same as \kbd{Flx\_gcd} without
collecting garbage.

\fun{GEN}{Flx_extgcd}{GEN a, GEN b, ulong p, GEN *ptu, GEN *ptv}

\fun{GEN}{Flx_pow}{GEN x, long n, ulong p}

\subsubsec{Miscellaneous operations}

\fun{GEN}{Flx_normalize}{GEN z, ulong p}, as \kbd{FpX\_normalize}.

\fun{GEN}{random_Flx}{long d, long sv, ulong p} returns a random \kbd{Flx}
in variable \kbd{v}, of degree less than~\kbd{d}.

\fun{GEN}{Flx_recip}{GEN x}, returns the reciprocal polynomial

\fun{ulong}{Flx_resultant}{GEN a, GEN b, ulong p}, returns the resultant
of \kbd{a} and \kbd{b}

\fun{ulong}{Flx_extresultant}{GEN a, GEN b, ulong p, GEN *ptU, GEN *ptV}
given two \kbd{Flx} \kbd{a} and \kbd{b},
returns their resultant and sets Bezout coefficients (if the resultant is 0,
the latter are not set).

\fun{GEN}{Flx_invmontgomery}{GEN T, ulong p}, returns the Montgomery inverse
of \kbd{T}, i.e.~\kbd{truncate(x / polrecip(T)+O(x\pow n))}. Assumes
$\kbd{T}(0) \neq 0$.

\fun{GEN}{Flx_rem_montgomery}{GEN x, GEN mg, GEN T, ulong p}, returns
\kbd{x} modulo \kbd{T}, where \kbd{mg} is the Montgomery inverse of \kbd{T}.

\fun{GEN}{Flx_renormalize}{GEN x, long l}, as \kbd{FpX\_renormalize}, where
$\kbd{l} = \kbd{lg(x)}$, in place.

\fun{GEN}{Flx_shift}{GEN T, long n}, returns \kbd{T} multiplied by $\kbd{x}^n$.

\fun{long}{Flx_valuation}{GEN x} returns the valuation of \kbd{x}, i.e. the
multiplicity of the $0$ root.

\fun{GEN}{FlxYqQ_pow}{GEN x, GEN n, GEN S, GEN T, ulong p}, as
\kbd{FpXQYQ\_pow}.


\fun{GEN}{Flx_div_by_X_x}{GEN A, ulong a, ulong p, ulong *rem}, returns the
Euclidean quotient of the \kbd{Flx}~\kbd{A} by $X - \kbd{a}$, and sets
\kbd{rem} to the remainder $ \kbd{A}(\kbd{a})$.

\fun{ulong}{Flx_eval}{GEN x, ulong y, ulong p}, as \kbd{FpX\_eval}.

\fun{GEN}{Flx_deflate}{GEN P, long d} assuming $P$ is a polynomial of the
form $Q(X^d)$, return $Q$.

\fun{GEN}{Flx_inflate}{GEN P, long d} returns $P(X^d)$.

\fun{GEN}{FlxV_Flc_mul}{GEN V, GEN W, ulong p}, as \kbd{FpXV\_FpC\_mul}.

\fun{int}{Flx_is_squarefree}{GEN z, ulong p}

\fun{long}{Flx_nbfact}{GEN z, ulong p}, as \kbd{FpX\_nbfact}.

\fun{long}{Flx_nbroots}{GEN f, ulong p}, as \kbd{FpX\_nbroots}.

\fun{GEN}{Flv_polint}{GEN x, GEN y, ulong p, long sv} as \kbd{FpV\_polint},
returning an \kbd{Flx} in variable $v$.

\fun{GEN}{Flv_roots_to_pol}{GEN a, ulong p, long sv} as
\kbd{FpV\_roots\_to\_pol} returning an \kbd{Flx} in variable $v$.

\subsec{\kbd{zx}}.

\fun{GEN}{zero_zx}{long sv} returns a zero \kbd{zx} in variable $v$.

\fun{GEN}{polx_zx}{long sv} returns the variable $v$ as degree~1~\kbd{Flx}.

\fun{GEN}{zx_shift}{GEN T, long n} returns \kbd{T}
multiplied by $\kbd{x}^n$.

\subsec{\kbd{Flxq}}. See \kbd{FpXQ} operations.

\fun{GEN}{Flxq_mul}{GEN x, GEN y, GEN T, ulong p}

\fun{GEN}{Flxq_sqr}{GEN y, GEN T, ulong p}

\fun{GEN}{Flxq_inv}{GEN x, GEN T, ulong p}

\fun{GEN}{Flxq_invsafe}{GEN x, GEN T, ulong p}

\fun{GEN}{Flxq_div}{GEN x, GEN y, GEN T, ulong p}

\fun{GEN}{Flxq_pow}{GEN x, GEN n, GEN T, ulong p}

\fun{GEN}{Flxq_powers}{GEN x, long n, GEN T, ulong p}

\fun{GEN}{Flxq_matrix_pow}{GEN x, long m, long n, GEN T, ulong p}, 
see \kbd{FpXQ\_matrix\_pow}.

\fun{GEN}{FlxqV_roots_to_pol}{GEN V, GEN T, ulong p, long v} as
\kbd{FqV\_roots\_to\_pol} returning an \kbd{FlxqX} in variable $v$.

\fun{GEN}{Flxq_order}{GEN a, GEN ord, GEN T, ulong p}
returns the order of the \typ{Flxq} \kbd{a}.
If \kbd{o} is non-\kbd{NULL}, it is assumed that \kbd{o} is a multiple of the
order of \kbd{a}, either as a \typ{INT} or a factorization matrix.


\fun{GEN}{Flxq_log}{GEN a, GEN g, GEN ord, GEN T, ulong p} Let $g$ of exact
order \kbd{ord} in the field $F_p[X]/(T)$. Return $e$ such that $a^e=g$. If
$e$ does not exists, the result is currently undefined.

\fun{GEN}{Flxq_sqrtn}{GEN x, GEN n, GEN T, ulong p, GEN *zn} returns an
\kbd{n}-th root of $\kbd{x}$.  Return \kbd{NULL} if \kbd{x} is not an
\kbd{n}-th power residue. Otherwise, if \kbd{zn} is non-\kbd{NULL} set it to a
primitive \kbd{n}-th root of $1$.

\fun{GEN}{Flxq_charpoly}{GEN x, GEN T, ulong p} returns the characteristic
polynomial of \kbd{x}

\fun{GEN}{Flxq_minpoly}{GEN x, GEN T, ulong p} returns the minimal polynomial
of \kbd{x}

\fun{GEN}{Flxq_norm}{GEN x, GEN T, ulong p} returns the norm of \kbd{x}

\fun{GEN}{gener_Flxq}{GEN T, ulong p} returns a primitive root modulo
$(T,p)$. $T$ is an \kbd{Flx} assumed to be irreducible modulo the prime
$p$.

\subsec{\kbd{FlxX}}. See \kbd{FpXX} operations.

\fun{GEN}{FlxX_add}{GEN P, GEN Q, ulong p}

\fun{GEN}{FlxY_Flx_div}{GEN x, GEN y, ulong p}

\fun{GEN}{FlxX_renormalize}{GEN x, long l}, as \kbd{normalizepol}, where
$\kbd{l} = \kbd{lg(x)}$, in place.

\fun{GEN}{FlxX_resultant}{GEN u, GEN v, ulong p, long sv} Returns
$\text{Res}_X(u, v)$, which is an \kbd{Flx}. The coefficients of \kbd{u}
and \kbd{v} are assumed to be in the variable $v$.

\fun{GEN}{Flx_FlxY_resultant}{GEN a, GEN b, ulong p}
Returns $\text{Res}_x(a, b)$, which is an \kbd{Flx}
in the main variable of \kbd{b}.

\fun{GEN}{FlxX_shift}{GEN a, long n}

\subsec{\kbd{FlxqX}}. See \kbd{FpXQX} operations.

\fun{GEN}{FlxqX_mul}{GEN x, GEN y, GEN T, ulong p}

\fun{GEN}{FlxqX_Flxq_mul}{GEN P, GEN U, GEN T, ulong p}

\fun{GEN}{FlxqX_normalize}{GEN z, GEN T, ulong p}

\fun{GEN}{FlxqX_sqr}{GEN x, GEN T, ulong p}

\fun{GEN}{FlxqX_divrem}{GEN x, GEN y, GEN T, ulong p, GEN *pr}

\fun{GEN}{FlxqX_red}{GEN z, GEN T, ulong p}

\fun{GEN}{FlxqXV_prod}{GEN V, GEN T, ulong p}

\fun{GEN}{FlxqXQ_pow}{GEN x, GEN n, GEN S, GEN T, ulong p}

\fun{GEN}{FlxqX_safegcd}{GEN P, GEN Q, GEN T, ulong p} Returns the gcd of $P$
and $Q$ if Euclid's algorithm succeeds and \kbd{NULL} otherwise. In
particular, if $p$ is not prime or $T$ is not irreducible over $\F_p[X]$, the
routine may still be used (but will fail if non-invertible leading terms
occur).

\subsec{\kbd{Flv}, \kbd{Flm}}. See \kbd{FpV}, \kbd{FpM} operations.

\fun{GEN}{Flm_Flc_mul}{GEN x, GEN y, ulong p}

\fun{GEN}{Flm_deplin}{GEN x, ulong p}

\fun{GEN}{Flm_gauss}{GEN a, GEN b, ulong p}

\fun{GEN}{Flm_indexrank}{GEN x, ulong p}

\fun{GEN}{Flm_inv}{GEN x, ulong p}

\fun{GEN}{Flm_ker}{GEN x, ulong p}

\fun{GEN}{Flm_ker_sp}{GEN x, ulong p, long deplin}, as \kbd{Flm\_ker}, in
place (destroys~\kbd{x}).

\fun{long}{Flm_rank}{GEN x, ulong p}

\fun{GEN}{Flm_mul}{GEN x, GEN y, ulong p}

\fun{GEN}{Flm_transpose}{GEN x}

\subsec{\kbd{FlxqV}, \kbd{FlxqM}}. See \kbd{FqV}, \kbd{FqM} operations.

\fun{GEN}{FlxqM_ker}{GEN x, GEN T, ulong p}

\subsec{\kbd{QX}}.

\fun{GEN}{QXQ_inv}{GEN A, GEN B} returns the inverse of \kbd{A} modulo \kbd{B}
where \kbd{A} and \kbd{B} are \kbd{QX}s.

\subsec{\kbd{RgX}}.

\fun{GEN}{RgX_add}{GEN x,GEN y} adds \kbd{x} and \kbd{y}.

\fun{GEN}{RgX_sub}{GEN x,GEN y} subtracts \kbd{x} and \kbd{y}.

\fun{GEN}{RgX_neg}{GEN x} returns $-\kbd{x}$.

The functions above are currently implemented through the generic routines,
but it might change in the future.

\fun{GEN}{RgX_mul}{GEN x, GEN y} multiplies the two \typ{POL} (in the same
variable) \kbd{x} and \kbd{y}. Uses Karatsuba algorithm.

\fun{GEN}{RgX_mulspec}{GEN a, GEN b, long na, long nb}. Internal routine:
\kbd{a} and \kbd{b} are arrays of coefficients representing polynomials
$\sum_{i = 0}^{\kbd{na}} \kbd{a}[i] X^i$ and
$\sum_{i = 0}^{\kbd{nb}} \kbd{b}[i] X^i$. Returns their product (as a true
\kbd{GEN}).

\fun{GEN}{RgX_sqr}{GEN x} squares the \typ{POL} \kbd{x}. Uses Karatsuba
algorithm.

\fun{GEN}{RgX_sqrspec}{GEN a, long na}. Internal routine:
\kbd{a} is an array of coefficients representing polynomial
$\sum_{i = 0}^{\kbd{na}} \kbd{a}[i] X^i$. Return its square (as a true
\kbd{GEN}).

\fun{GEN}{RgX_divrem}{GEN x, GEN y, GEN *r}

\fun{GEN}{RgX_div}{GEN x, GEN y, GEN *r}

\fun{GEN}{RgX_div_by_X_x}{GEN A, GEN a, GEN *r} returns the
quotient of the \kbd{RgX}~\kbd{A} by $(X - \kbd{a})$, and sets \kbd{r} to the
remainder $\kbd{A}(\kbd{a})$.

\fun{GEN}{RgX_rem}{GEN x, GEN y, GEN *r}

\fun{GEN}{RgX_mulXn}{GEN x, long n} returns $\kbd{x} * t^n$. This may
be a \typ{FRAC} if $n < 0$ and the valuation of \kbd{x} is not large
enough.

\fun{GEN}{RgX_shift}{GEN x, long n} returns $\kbd{x} * t^n$ if $n\geq 0$,
and $\kbd{x} \bs t^{-n}$ otherwise.

\fun{GEN}{RgX_shift_shallow}{GEN x, long n} as \kbd{RgX\_shift}, but
shallow (coefficients are not copied).

\fun{GEN}{RgX_modXn_shallow}{GEN x, long n} return $\kbd{x \% } t^n$,
where $n\geq 0$. Shallow function.

\fun{GEN}{RgX_extgcd}{GEN x, GEN y, GEN *u, GEN *v} returns
$d = \text{GCD}(\kbd{x},\kbd{y})$, and sets \kbd{*u}, \kbd{*v} to the Bezout
coefficients such that $\kbd{*ux} + \kbd{*vy} = d$.

\fun{GEN}{RgX_renormalize}{GEN x} remove leading terms in \kbd{x} which are
equal to (necessarily inexact) zeros.

\fun{GEN}{RgX_deflate}{GEN P, long d} assuming $P$ is a polynomial of the
form $Q(X^d)$, return $Q$. Shallow function, not suitable for
\kbd{gerepileupto}.

\fun{GEN}{RgX_inflate}{GEN P, long d} return $P(X^d)$. Shallow function, not
suitable for \kbd{gerepileupto}.

\fun{GEN}{RgX_rescale}{GEN P, GEN h} returns $h^{\deg(P)} P(x/h)$.
\kbd{P} is an \kbd{RgX} and \kbd{h} is non-zero. (Leaves small objects on the
stack. Suitable but inefficient for \kbd{gerepileupto}.)

\fun{GEN}{RgX_unscale}{GEN P, GEN h} returns $P(h x)$. (Leaves small objects
on the stack. Suitable but inefficient for \kbd{gerepileupto}.)

\fun{GEN}{RgXV_unscale}{GEN v, GEN h} apply \kbd{RgX\_unscale} to a vector
of \kbd{RgX}.

\fun{int}{RgX_is_rational}{GEN P} return 1 is the \kbd{RgX}~\kbd{P} hasonly
rational coefficients (\typ{INT} and \typ{FRAC}), and 0 otherwise.

\smallskip

\fun{GEN}{RgXQ_mul}{GEN y, GEN x, GEN T}

\fun{GEN}{RgXQ_norm}{GEN x, GEN T} returns the norm of \kbd{Mod(x, T)}.

\fun{GEN}{RgXQ_sqr}{GEN x, GEN T}

\fun{GEN}{RgXQ_inv}{GEN x, GEN T} return the inverse of $x$ mod $T$.

\fun{GEN}{RgXQ_powers}{GEN x, long n, GEN T} returns $[\kbd{x}^0,
\dots, \kbd{x}^\kbd{n}]$ as a \typ{VEC} of \kbd{RgXQ}s.

\fun{GEN}{RgXQ_matrix_pow}{GEN y, long n, long m, GEN P} returns
\kbd{RgXQ\_powers(y,m-1,P)} as a matrix of dimension $n \geq \deg P$.

\fun{GEN}{RgX_RgXQ_compo}{GEN f,GEN x,GEN T} returns
$\kbd{f}(\kbd{x})$ modulo $T$.

\fun{GEN}{RgXQC_red}{GEN z, GEN T} \kbd{z} a vector whose
coefficients are \kbd{RgX}s (arbitrary \kbd{GEN}s in fact), reduce them to
\kbd{RgXQ}s (applying \kbd{grem} coefficientwise) in a \typ{COL}.

\fun{GEN}{RgXQV_red}{GEN z, GEN T} \kbd{z} a \typ{POL} whose
coefficients are \kbd{RgX}s (arbitrary \kbd{GEN}s in fact), reduce them to
\kbd{RgXQ}s (applying \kbd{grem} coefficientwise) in a \typ{VEC}.

\fun{GEN}{RgXQX_red}{GEN z, GEN T} \kbd{z} a \typ{POL} whose
coefficients are \kbd{RgX}s (arbitrary \kbd{GEN}s in fact), reduce them to
\kbd{RgXQ}s (applying \kbd{grem} coefficientwise).

\fun{GEN}{RgXQX_mul}{GEN x, GEN y, GEN T}

\fun{GEN}{RgX_Rg_mul}{GEN y, GEN x} multiplies the \kbd{RgX} \kbd{y}
by the scalar \kbd{x}.

\fun{GEN}{RgX_Rg_div}{GEN y, GEN x} divides the \kbd{RgX} \kbd{y}
by the scalar \kbd{x}.

\fun{GEN}{RgXQX_RgXQ_mul}{GEN x, GEN y, GEN T} multiplies the \kbd{RgXQX}
\kbd{y} by the scalar (\kbd{RgXQ}) \kbd{x}.

\fun{GEN}{RgXQX_sqr}{GEN x, GEN T}

\fun{GEN}{RgXQX_divrem}{GEN x, GEN y, GEN T, GEN *pr}

\fun{GEN}{RgXQX_div}{GEN x, GEN y, GEN T, GEN *r}

\fun{GEN}{RgXQX_rem}{GEN x, GEN y, GEN T, GEN *r}

\subsec{Hensel lifts}

\fun{GEN}{padicsqrtlift}{GEN a, GEN S, GEN p, long e} returns a \typ{INT}
which is a square root of $a$ mod $p^e$, assuming $S$ is a square root mod
$p$. $p$ is odd.

\fun{GEN}{padicsqrtnlift}{GEN a, GEN n, GEN S, GEN p, long e} returns a
\typ{INT} which is an $n$-th root of $a$ mod $p^e$, assuming $S$ is an
$n$-th root mod $p$. Assumes $n > 1$ and $p$ does not divide $n$.

%\fun{GEN}{rootpadicfast}{GEN f, GEN p, long e} $f$ a \kbd{ZX} with leading
%term prime to $p$, and without multiple roots mod $p$. Return a vector
%of \typ{INT}s which are the roots of $f$ mod $p^e$.

\fun{GEN}{ZpX_liftroot}{GEN f, GEN a, GEN p, long e} $f$ a \kbd{ZX} with
leading term prime to $p$, and $a$ a simple root mod $p$. Return a \typ{INT}
which are the root of $f$ mod $p^e$ congruent to $a$ mod $p$.

\fun{GEN}{ZpX_liftroots}{GEN f, GEN S, GEN q, long e} $f$ a \kbd{ZX} with
leading term prime to $p$, and $S$ a vector of simple roots mod $p$. Return a
vector of \typ{INT}s which are the root of $f$ mod $p^e$ congruent to the
$S[i]$ mod $p$.

\fun{GEN}{ZpXQX_liftroot}{GEN f, GEN a, GEN T, GEN p, long e} as
\tet{ZpX_liftroot}, but $f$ is now a polynomial in $\Z[X,Y]$ and we find
roots in the unramified extension of $\Q_p$ with reidue field $\F_p[Y]/(T)$.

\subsec{Conversions involving single precision objects}

\subsubsec{To single precision}

\fun{GEN}{ZX_to_Flx}{GEN x, ulong p} reduce \kbd{ZX}~\kbd{x} modulo \kbd{p}
(yielding an \kbd{Flx}).

\fun{GEN}{ZV_to_Flv}{GEN x, ulong p} reduce \kbd{ZV}~\kbd{x} modulo \kbd{p}
(yielding an \kbd{Flv}).

\fun{GEN}{ZXV_to_FlxV}{GEN v, ulong p}, as \kbd{ZX\_to\_Flx}, repeatedly
called on the vector's coefficients.

\fun{GEN}{ZXX_to_FlxX}{GEN B, ulong p, long v}, as \kbd{ZX\_to\_Flx},
repeatedly called on the polynomial's coefficients.

\fun{GEN}{ZXXV_to_FlxXV}{GEN V, ulong p, long v}, as \kbd{ZXX\_to\_FlxX},
repeatedly called on the vector's coefficients.

\fun{GEN}{ZM_to_Flm}{GEN x, ulong p} reduce \kbd{ZM}~\kbd{x} modulo \kbd{p}
(yielding an \kbd{Flm}).

\fun{GEN}{ZV_to_zv}{GEN z}, converts coefficients using \kbd{itos}

\fun{GEN}{ZV_to_nv}{GEN z}, converts coefficients using \kbd{itou}

\fun{GEN}{ZM_to_zm}{GEN z}, converts coefficients using \kbd{itos}

\fun{GEN}{FqC_to_FlxC}{GEN x, GEN T, GEN p}, converts coefficients in \kbd{Fq}
to coefficient in Flx, result being a column vector.

\fun{GEN}{FqV_to_FlxV}{GEN x, GEN T, GEN p}, converts coefficients in \kbd{Fq}
to coefficient in Flx, result being a line vector.

\fun{GEN}{FqM_to_FlxM}{GEN x, GEN T, GEN p}, converts coefficients in \kbd{Fq}
to coefficient in Flx.

\subsubsec{From single precision}

\fun{GEN}{Flx_to_ZX}{GEN z}, converts to \kbd{ZX} (\typ{POL} of non-negative
\typ{INT}s in this case)

\fun{GEN}{Flx_to_ZX_inplace}{GEN z}, same as \kbd{Flx\_to\_ZX}, in place
(\kbd{z} is destroyed).

\fun{GEN}{FlxX_to_ZXX}{GEN B}, converts an \kbd{FlxX} to a polynomial with
\kbd{ZX} or \typ{INT} coefficients (repeated calls to \kbd{Flx\_to\_ZX}).

\fun{GEN}{FlxC_to_ZXC}{GEN x}, converts a vector of \kbd{Flx} to a column
vector of polynomials with \typ{INT} coefficients (repeated calls to
\kbd{Flx\_to\_ZX}).

\fun{GEN}{FlxM_to_ZXM}{GEN z}, converts a matrix of \kbd{Flx} to a matrix of
polynomials with \typ{INT} coefficients (repeated calls to \kbd{Flx\_to\_ZX}).

\fun{GEN}{zx_to_ZX}{GEN z}, as \kbd{Flx\_to\_ZX}, without assuming
coefficients are non-negative.

\fun{GEN}{Flc_to_ZC}{GEN z}, converts to \kbd{ZC} (\typ{COL} of non-negative
\typ{INT}s in this case)

\fun{GEN}{Flv_to_ZV}{GEN z}, converts to \kbd{ZV} (\typ{VEC} of non-negative
\typ{INT}s in this case)

\fun{GEN}{Flm_to_ZM}{GEN z}, converts to \kbd{ZM} (\typ{MAT} with
non-negative \typ{INT}s coefficients in this case)

\fun{GEN}{zc_to_ZC}{GEN z} as \kbd{Flc\_to\_ZC}, without assuming
coefficients are non-negative.

\fun{GEN}{zv_to_ZV}{GEN z} as \kbd{Flv\_to\_ZV}, without assuming
coefficients are non-negative.

\fun{GEN}{zm_to_ZM}{GEN z} as \kbd{Flm\_to\_ZM}, without assuming
coefficients are non-negative.

\subsubsec{Mixed precision linear algebra} Assumes dimensions are compatible.
Multiply a multiprecision object by a single-precision one.

\fun{GEN}{RgM_zc_mul}{GEN x, GEN y}

\fun{GEN}{RgM_zm_mul}{GEN x, GEN y}

\fun{GEN}{RgV_zc_mul}{GEN x, GEN y}

\fun{GEN}{RgV_zm_mul}{GEN x, GEN y}

\fun{GEN}{ZM_zc_mul}{GEN x, GEN y}

\fun{GEN}{ZM_zm_mul}{GEN x, GEN y}

\subsubsec{Miscellaneous}

\fun{GEN}{zero_Flx}{long sv} returns a zero \kbd{Flx} in variable $v$.

\fun{GEN}{polx_Flx}{long sv} returns the variable $v$ as degree~1~\kbd{Flx}.

\fun{GEN}{Fl_to_Flx}{ulong x, long evx} converts a \kbd{unsigned long} to a
scalar \kbd{Flx}. Assume that \kbd{evx = evalvarn(vx)} for some variable
number \kbd{vx}.

\fun{GEN}{Z_to_Flx}{GEN x, ulong p, long v} converts a \typ{INT} to a scalar
polynomial in variable $v$.

\fun{GEN}{Flx_to_Flv}{GEN x, long n} converts from \kbd{Flx} to \kbd{Flv}
with \kbd{n} components (assumed larger than the number of coefficients of
\kbd{x}).

\fun{GEN}{zx_to_zv}{GEN x, long n} as \kbd{Flx\_to\_Flv}.

\fun{GEN}{Flv_to_Flx}{GEN x, long sv} converts from vector (coefficient
array) to (normalized) polynomial in variable $v$.

\fun{GEN}{zv_to_zx}{GEN x, long n} as \kbd{Flv\_to\_Flx}.

\fun{GEN}{zv_neg}{GEN x} return $-x$. No check for overflow is done, which
occurs in the fringe case where an entry is equal to $2^{\B-1}$.

\fun{GEN}{matid_Flm}{long n} returns an \kbd{Flm} which is an $n \times n$
identity matrix.

\fun{GEN}{Flm_to_FlxV}{GEN x, long sv} converts the columns of
\kbd{Flm}~\kbd{x} to an array of \kbd{Flx} in the variable $v$
(repeated calls to \kbd{Flv\_to\_Flx}).

\fun{GEN}{zm_to_zxV}{GEN x, long n} as \kbd{Flm\_to\_FlxV}.

\fun{GEN}{zm_transpose}{GEN x}

\fun{GEN}{Flm_to_FlxX}{GEN x, long sw, long sv} same as
\kbd{Flm\_to\_FlxV(x,sv)} but returns the result as a (normalized) polynomial
in variable $w$.

\fun{GEN}{FlxV_to_Flm}{GEN v, long n} reverse \kbd{Flm\_to\_FlxV}, to obtain
an \kbd{Flm} with \kbd{n} rows (repeated calls to \kbd{Flx\_to\_Flv}).

\fun{GEN}{FlxX_to_Flm}{GEN v, long n} reverse \kbd{Flm\_to\_FlxX}, to obtain
an \kbd{Flm} with \kbd{n} rows (repeated calls to \kbd{Flx\_to\_Flv}).

\fun{GEN}{Fly_to_FlxY}{GEN a, long sv} convert coefficients of \kbd{a} to
constant \kbd{Flx} in variable $v$.

\section{Operations on general PARI objects}

\subsec{Assignment}

\fun{void}{gaffsg}{long s, GEN x} assigns the \kbd{long}~\kbd{s} into the
object~\kbd{x}.

\fun{void}{gaffect}{GEN x, GEN y} assigns the object \kbd{x} into the
object~\kbd{y}. Both \kbd{x} and \kbd{y} must be scalar types.

\subsec{Conversions}

\subsubsec{Scalars}

\fun{double}{rtodbl}{GEN x} applied to a \typ{REAL}~\kbd{x}, converts \kbd{x}
into a \kbd{double} if possible.

\fun{GEN}{dbltor}{double x} converts the \kbd{double} \kbd{x} into a
\typ{REAL}.

\fun{double}{gtodouble}{GEN x} if \kbd{x} is a real number (not necessarily
a~\typ{REAL}), converts \kbd{x} into a \kbd{double} if possible.

\fun{long}{gtos}{GEN x} converts the \typ{INT} \kbd{x} to a small
integer if possible, otherwise raise an exception. This function
is similar to \tet{itos}, slightly slower since it checks the type of \kbd{x}.

\fun{double}{dbllog2r}{GEN x} assuming \kbd{x} is a non-zero \typ{REAL},
returns an aproximation to \kbd{log2(|x|)}.

\fun{long}{gtolong}{GEN x} if \kbd{x} is an integer (not necessarily
a~\typ{INT}), converts \kbd{x} into a \kbd{long} if possible.

\fun{GEN}{fractor}{GEN x, long l} applied to a \typ{FRAC}~\kbd{x}, converts
\kbd{x} into a \typ{REAL} of length \kbd{prec}.

\fun{GEN}{quadtoc}{GEN x, long l} applied to a \typ{QUAD}~\kbd{x}, converts
\kbd{x} into a \typ{REAL} or \typ{COMPLEX} depending on the sign of the
discriminant of~\kbd{x}, to precision \hbox{\kbd{l} \B-bit} words.% forbid
line brk at hyphen here [GN]

\fun{GEN}{ctofp}{GEN x, long prec} converts the \typ{COMPLEX}~\kbd{x} to a
a complex whose real and imaginary parts are \typ{REAL} of length \kbd{prec},
using \kbd{gtofp};

\fun{GEN}{gtofp}{GEN x, long prec} converts the complex number~\kbd{x}
(\typ{INT}, \typ{REAL}, \typ{FRAC}, \typ{QUAD} or \typ{COMPLEX}) to either
a \typ{REAL} or \typ{COMPLEX} whose components are \typ{REAL} of length
\kbd{prec}.

\fun{GEN}{gcvtop}{GEN x, GEN p, long l} converts \kbd{x} into a \typ{PADIC}
\kbd{p}-adic number of precision~\kbd{l}.

\fun{GEN}{gprec}{GEN x, long l} returns a copy of $x$ whose precision is
changed to $l$ digits. The precision change is done recursively on all
components of $x$. Digits means \emph{decimal}, $p$-adic and $X$-adic digits
for \typ{REAL}, \typ{SER}, \typ{PADIC} components, respectively.

\fun{GEN}{gprec_w}{GEN x, long l} returns a shallow copy of $x$ whose
\typ{REAL} components have their precision changed to $l$ \emph{words}. This
is often more useful than \kbd{gprec}.

\fun{GEN}{gprec_wtrunc}{GEN x, long l} returns a shallow copy of $x$ whose
\typ{REAL} components have their precision \emph{truncated} to $l$
\emph{words}. Contrary to \kbd{gprec\_w}, this function may never increase
the precision of~$x$.

\subsubsec{Modular objects}

\fun{GEN}{gmodulo}{GEN x, GEN y} creates the object \kbd{\key{Mod}(x,y)} on
the PARI stack, where \kbd{x} and \kbd{y} are either both \typ{INT}s, and the
result is a \typ{INTMOD}, or \kbd{x} is a scalar or a \typ{POL} and \kbd{y} a
\typ{POL}, and the result is a \typ{POLMOD}.

\fun{GEN}{gmodulgs}{GEN x, long y} same as \key{gmodulo} except \kbd{y} is a
\kbd{long}.

\fun{GEN}{gmodulss}{long x, long y} same as \key{gmodulo} except both
\kbd{x} and \kbd{y} are \kbd{long}s.

\subsubsec{Between polynomials and coefficient arrays}

\fun{GEN}{gtopoly}{GEN x, long v} converts or truncates the object~\kbd{x}
into a \typ{POL} with main variable number~\kbd{v}. A common application
would be the conversion of coefficient vectors (coefficients are given by
decreasing degree). E.g.~\kbd{[2,3]} goes to \kbd{2*v + 3}

\fun{GEN}{gtopolyrev}{GEN x, long v} converts or truncates the object~\kbd{x}
into a \typ{POL} with main variable number~\kbd{v}, but vectors are converted
in reverse order compared to \kbd{gtopoly} (coefficients are given by
increasing degree). E.g.~\kbd{[2,3]} goes to \kbd{3*v + 2}. In other words
the vector represents a polynomial in the basis $(1,v,v^2,v^3,\dots)$.

\fun{GEN}{normalizepol}{GEN x} applied to an unnormalized \typ{POL}~\kbd{x}
(with all coefficients correctly set except that \kbd{leading\_term(x)} might
be zero), normalizes \kbd{x} correctly in place and returns~\kbd{x}. For
internal use.

The following routines do \emph{not} copy coefficients on the stack (they
only move pointers around), hence are very fast but not suitable for
\kbd{gerepile} calls. Recall that an \kbd{RgV} (resp.~an \kbd{RgX}, resp.~an
\kbd{RgM}) is a \typ{VEC} or \typ{COL} (resp.~a \typ{POL}, resp.~a \typ{MAT})
with arbitrary components. Similarly, an \kbd{RgXV} is a \typ{VEC} or
\typ{COL} with \kbd{RgX} components, etc.

\fun{GEN}{RgV_to_RgX}{GEN x, long v} converts the \kbd{RgV}~\kbd{x} to a
(normalized) polynomial in variable~\kbd{v} (as \kbd{gtopolyrev}, without
copy).

\fun{GEN}{RgX_to_RgV}{GEN x, long N} converts the \typ{POL}~\kbd{x} to a
\typ{COL}~\kbd{v} with \kbd{N} components. Other types than \typ{POL} are
allowed for \kbd{x}, which is then considered as a constant polynomial.
Coefficients of \kbd{x} are listed by increasing degree, so that \kbd{y[i]}
is the coefficient of the term of degree $i-1$ in \kbd{x}.

\fun{GEN}{RgM_to_RgXV}{GEN x, long v} converts the \kbd{RgM}~\kbd{x} to a
\typ{VEC} of \kbd{RgX}, by repeated calls to \kbd{RgV\_to\_RgX}.

\fun{GEN}{RgXV_to_RgM}{GEN v, long N} converts the vector of \kbd{RgX}~\kbd{v}
to a~\typ{MAT} with \kbd{N}~rows, by repeated calls to \kbd{RgX\_to\_RgV}.

\fun{GEN}{RgM_to_RgXX}{GEN x, long v,long w} converts the \kbd{RgM}~\kbd{x} into
a \typ{POL} in variable~\kbd{v}, whose coefficients are \typ{POL}s in
variable~\kbd{w}. This is a shortcut for
\bprog
  RgV_to_RgX( RgM_to_RgXV(x, w), v );
@eprog\noindent
There are no consistency checks with respect to variable
priorities: the above is an invalid object if $\kbd{varncmp(v, w)} \geq 0$.

\fun{GEN}{RgXX_to_RgM}{GEN x, long N} converts the \typ{POL}~\kbd{x} with
\kbd{RgX} (or constant) coefficients to a matrix with \kbd{N} rows.

\fun{GEN}{RgXY_swap}{GEN P, long n, long w} converts the bivariate polynomial
$\kbd{P}(u,v)$ (a \typ{POL} with \typ{POL} coefficients) to
$P(\kbd{pol\_x[w]},u)$, assuming \kbd{n} is an upper bound for
$\deg_v(\kbd{P})$.

\fun{GEN}{greffe}{GEN x, long l, int use_stack} applied to a
\typ{POL}~\kbd{x}, creates a \typ{SER} of length~\kbd{l} starting
with~\kbd{x}, but without actually copying the coefficients, just the
pointers. If \kbd{use\_stack} is $0$, this is created through malloc, and
must be freed after use. Intended for internal use only.

\fun{GEN}{gtoser}{GEN x, long v} converts the object~\kbd{x} into a \typ{SER}
with main variable number~\kbd{v}.

\fun{GEN}{gtocol}{GEN x} converts the object~\kbd{x} into a \typ{COL}

\fun{GEN}{gtomat}{GEN x} converts the object~\kbd{x} into a \typ{MAT}.

\fun{GEN}{gtovec}{GEN x} converts the object~\kbd{x} into a \typ{VEC}.

\fun{GEN}{gtovecsmall}{GEN x} converts the object~\kbd{x} into a
\typ{VECSMALL}.

\fun{GEN}{normalize}{GEN x} applied to an unnormalized \typ{SER}~\kbd{x}
(i.e.~type \typ{SER} with all coefficients correctly set except that \kbd{x[2]}
might be zero), normalizes \kbd{x} correctly in place. Returns~\kbd{x}.
For internal use.

\subsec{Clean Constructors}\label{se:clean}

\fun{GEN}{zeropadic}{GEN p, long n} creates a $0$ \typ{PADIC} equal to
$O(\kbd{p}^\kbd{n})$.

\fun{GEN}{zeroser}{long v, long n} creates a $0$ \typ{SER} in variable
\kbd{v} equal to $O(X^\kbd{n})$.

\fun{GEN}{scalarser}{GEN x, long v, long prec} creates a constant \typ{SER}
in variable \kbd{v} and precision \kbd{prec}, whose constant coefficient is
(a copy of) \kbd{x}, in other words $\kbd{x} + O(\kbd{v}^\kbd{prec})$.
Assumes that \kbd{x} is non-zero.

\fun{GEN}{zeropol}{long v} creates a $0$ \typ{POL} in variable \kbd{v}.

\fun{GEN}{scalarpol}{GEN x, long v} creates a constant \typ{POL} in variable
\kbd{v}, whose constant coefficient is (a copy of) \kbd{x}.


\fun{GEN}{zerocol}{long n} creates a \typ{COL} with \kbd{n} components set to
\kbd{gen\_0}.

\fun{GEN}{zerovec}{long n} creates a \typ{VEC} with \kbd{n} components set to
\kbd{gen\_0}.

\fun{GEN}{col_ei}{long n, long i} creates a \typ{COL} with \kbd{n} components
set to \kbd{gen\_0}, but for the \kbd{i}-th one which is set to \kbd{gen\_1}
(\kbd{i}-th vector in the canonical basis).

\fun{GEN}{vec_ei}{long n, long i} creates a \typ{VEC} with \kbd{n} components
set to \kbd{gen\_0}, but for the \kbd{i}-th one which is set to \kbd{gen\_1}
(\kbd{i}-th vector in the canonical basis).

\fun{GEN}{scalarcol}{GEN x, long n} creates a \typ{COL} with \kbd{n}
components set to \kbd{gen\_0}, but the first one which is set to a copy
of \kbd{x}. (The name comes from \kbd{RgV\_isscalar}.)

\smallskip

\fun{GEN}{zeromat}{long m, long n} creates a \typ{MAT} with \kbd{m} x \kbd{n}
components set to \kbd{gen\_0}. Note that the result allocates a
\emph{single} column, so modifying an entry in one column modifies it in
all columns. To fully allocate a matrix initialized with zero entries,
use \kbd{zeromatcopy}.

\fun{GEN}{zeromatcopy}{long m, long n} creates a \typ{MAT} with \kbd{m} x
\kbd{n} components set to \kbd{gen\_0}. Note that

\fun{GEN}{matid}{long n} identity matrix in dimension \kbd{n} (with
components \kbd{gen\_1} and\kbd{gen\_0}).

\fun{GEN}{scalarmat}{GEN x, long n} scalar matrix, \kbd{x} times the identity.

\fun{GEN}{scalarmat_s}{long x, long n} scalar matrix, \kbd{stoi(x)} times
the identity.

\smallskip
See also next section for analogs of the following functions:

\fun{GEN}{mkcolcopy}{GEN x} creates a 1-dimensional \typ{COL} containing
\kbd{x}.

\fun{GEN}{mkmatcopy}{GEN x} creates a 1-by-1 \typ{MAT} containing \kbd{x}.

\fun{GEN}{mkveccopy}{GEN x} creates a 1-dimensional \typ{VEC} containing
\kbd{x}.

\fun{GEN}{mkvec2copy}{GEN x, GEN y} creates a 2-dimensional \typ{VEC} equal
to \kbd{[x,y]}.

\fun{GEN}{mkvecs}{long x} creates a 1-dimensional \typ{VEC}
containing \kbd{stoi(x)}.

\fun{GEN}{mkvec2s}{long x, long y} creates a 2-dimensional \typ{VEC}
containing \kbd{[stoi(x), stoi(y)]}.

\fun{GEN}{mkvec3s}{long x, long y, long z} creates a 3-dimensional \typ{VEC}
containing \kbd{[stoi(x), stoi(y), stoi(z)]}.


\fun{GEN}{mkvecsmall}{long x} creates a 1-dimensional \typ{VECSMALL}
containing \kbd{x}.

\fun{GEN}{mkvecsmall2}{long x, long y} creates a 2-dimensional \typ{VECSMALL}
containing \kbd{[x, y]}.

\fun{GEN}{mkvecsmall3}{long x, long y, long z} creates a 3-dimensional
\typ{VECSMALL} containing \kbd{[x, y, z]}.

\subsec{Unclean Constructors}\label{se:unclean}

Contrary to the policy of general PARI functions, the functions in this
subsection do \emph{not} copy their arguments, nor do they produce an object
a priori suitable for \tet{gerepileupto}. In particular, they are
faster than their clean equivalent (which may not exist). \emph{If} you
restrict their arguments to universal objects (e.g \kbd{gen\_0}),
then the above warning does not apply.

\fun{GEN}{mkcomplex}{GEN x, GEN y} creates the \typ{COMPLEX} $x + iy$.

\fun{GEN}{mulcxI}{GEN x} creates the \typ{COMPLEX} $ix$. The result in
general contains data pointing back to the original $x$. Use \kbd{gcopy} if
this is a problem. But in most cases, the result is to be used immediately,
before $x$ is subject to garbage collection.

\fun{GEN}{mulcxmI}{GEN x}, as \tet{mulcxI}, but returns the \typ{COMPLEX}
$-ix$.

\fun{GEN}{mkfrac}{GEN x, GEN y} creates the \typ{FRAC} $x/y$. Assumes that
$y > 1$ and $(x,y) = 1$.

\fun{GEN}{mkrfrac}{GEN x, GEN y} creates the \typ{RFRAC} $x/y$. Assumes
that $y$ is a \typ{POL}, $x$ a compatible type whose variable has lower
or same priority, with $(x,y) = 1$.

\fun{GEN}{mkcol}{GEN x} creates a 1-dimensional \typ{COL} containing \kbd{x}.

\fun{GEN}{mkintmod}{GEN x, GEN y} creates the \typ{INTMOD} \kbd{Mod(x, y)}.
The input must be \typ{INT}s satisfying $0 \leq x < y$.

\fun{GEN}{mkpolmod}{GEN x, GEN y} creates the \typ{POLMOD} \kbd{Mod(x, y)}.
The input must satisfy $\deg x < \deg y$ with respect to the main variable of
the \typ{POL} $y$. $x$ may be a scalar.

\fun{GEN}{mkmat}{GEN x} creates a 1-by-1 \typ{MAT} containing \kbd{x}.

\fun{GEN}{mkvec}{GEN x} creates a 1-dimensional \typ{VEC} containing \kbd{x}.

\fun{GEN}{mkvec2}{GEN x, GEN y} creates a 2-dimensional \typ{VEC} equal to
\kbd{[x,y]}.

\fun{GEN}{mkvec3}{GEN x, GEN y, GEN z} creates a 3-dimensional \typ{VEC}
equal to \kbd{[x,y,z]}.

\fun{GEN}{mkvec4}{GEN x, GEN y, GEN z, GEN t} creates a 4-dimensional \typ{VEC}
equal to \kbd{[x,y,z,t]}.

\smallskip

\fun{GEN}{mkintn}{long n, ...} returns the non-negative \typ{INT} whose
development in base $2^{32}$ is given by the following $n$ words
(\kbd{unsigned long}). It is assumed that all such arguments are less than
$2^{32}$ (the actual \kbd{sizeof(long)} is irrelevant, the behaviour is also
as above on $64$-bit machines).
\bprog
  mkintn(3, a2, a1, a0);
@eprog
\noindent returns $a_2 2^{64} + a_1 2^{32} + a_0$.

\fun{GEN}{pol_1}{long v} Returns the constant polynomial $1$ in variable $v$.

\fun{GEN}{pol_x}{long v} Returns the monomial of degree $1$ in variable $v$.

\fun{GEN}{mkpoln}{long n, ...} Returns the \typ{POL} whose $n$
coefficients (\kbd{GEN}) follow, in order of decreasing degree.
\bprog
  mkpoln(3, gen_1, gen_2, gen_0);
@eprog
\noindent returns the polynomial $X^2 + 2X$ (in variable $0$, use
\tet{setvarn} if you want other variable numbers). Beware that $n$ is the
number of coefficients, hence \emph{one more} than the degree.

\fun{GEN}{mkvecn}{long n, ...} returns the \typ{VEC} whose $n$
coefficients (\kbd{GEN}) follow.

\fun{GEN}{mkcoln}{long n, ...} returns the \typ{COL} whose $n$
coefficients (\kbd{GEN}) follow.

\fun{GEN}{mkvecsmalln}{long n, ...} returns the \typ{VECSMALL} whose $n$
coefficients (\kbd{long}) follow.

\fun{GEN}{scalarcol_shallow}{GEN x, long n} creates a \typ{COL} with \kbd{n}
components set to \kbd{gen\_0}, but the first one which is set to a shallow
copy of \kbd{x}. (The name comes from \kbd{RgV\_isscalar}.)

\fun{GEN}{scalarmat_shallow}{GEN x, long n} creates an $n\times n$
scalar matrix whose diagonal is set to shallow copies of the scalar \kbd{x}.

\subsec{Integer parts}

\fun{GEN}{gfloor}{GEN x} creates the floor of~\kbd{x}, i.e.\ the (true)
integral part.

\fun{GEN}{gfloor2n}{GEN x, long n} creates the floor of~$2^n$\kbd{x}, this is
only implemented for \typ{INT}, \typ{REAL}, and \typ{COMPLEX} of those.

\fun{GEN}{gfrac}{GEN x} creates the fractional part of~\kbd{x}, i.e.\ \kbd{x}
minus the floor of~\kbd{x}.

\fun{GEN}{gceil}{GEN x} creates the ceiling of~\kbd{x}.

\fun{GEN}{ground}{GEN x} rounds towards~$+\infty$ the components of \kbd{x}
to the nearest integers.

\fun{GEN}{grndtoi}{GEN x, long *e} same as \kbd{ground}, but in addition sets
\kbd{*e} to the binary exponent of $x - \kbd{ground}(x)$. If this is
positive, all significant bits are lost. This kind of situation raises an
error message in \key{ground} but not in \key{grndtoi}.

\fun{GEN}{gtrunc}{GEN x} truncates~\kbd{x}. This is the false integer part
if \kbd{x} is a real number (i.e.~the unique integer closest to \kbd{x} among
those between 0 and~\kbd{x}). If \kbd{x} is a \typ{SER}, it is truncated
to a \typ{POL}; if \kbd{x} is a \typ{RFRAC}, this takes the polynomial part.

\fun{GEN}{gcvtoi}{GEN x, long *e} same as \key{grndtoi} except that
rounding is replaced by truncation.

\subsec{Valuation and shift}

\fun{GEN}{gshift[z]}{GEN x, long n[, GEN z]} yields the result of shifting
(the components of) \kbd{x} left by \kbd{n} (if \kbd{n} is non-negative)
or right by $-\kbd{n}$ (if \kbd{n} is negative). Applies only to \typ{INT}
and vectors/matrices of such. For other types, it is simply multiplication
by~$2^{\kbd{n}}$.

\fun{GEN}{gmul2n[z]}{GEN x, long n[, GEN z]} yields the product of \kbd{x}
and~$2^{\kbd{n}}$. This is different from \kbd{gshift} when \kbd{n} is negative
and \kbd{x} is a \typ{INT}: \key{gshift} truncates, while \key{gmul2n}
creates a fraction if necessary.

\fun{long}{ggval}{GEN x, GEN p} returns the greatest exponent~$e$ such that
$\kbd{p}^e$ divides~\kbd{x}, when this makes sense.

\fun{long}{gval}{GEN x, long v} returns the highest power of the variable
number \kbd{v} dividing the \typ{POL}~\kbd{x}.

\fun{long}{polvaluation}{GEN P, GEN *z} returns the valuation $v$ of the
\typ{POL}~\kbd{P} with respect to its main variable $X$. Check whether
coefficients are $0$ using \kbd{gcmp0}. If \kbd{z} is non-\kbd{NULL}, set it
to $\kbd{P} / X^v$.

\fun{long}{polvaluation_inexact}{GEN P, GEN *z} as \kbd{polvaluation}
but use \kbd{isexactzero} instead of \kbd{gcmp0}.

\fun{long}{poldeflate}{GEN P, long *d} sets \kbd{d} to the largest exponent
such that $P$ is of the form $P(x^d)$ (use \kbd{gcmp0} to check
coefficients), $0$ if $P$ is the zero polynomial. Returns
\kbd{RgX\_deflate(P,d)}.

\fun{long}{ZX_valuation}{GEN P, GEN *z} as \kbd{polvaluation}, but assumes
\kbd{P} has \typ{INT} coefficients.

\subsec{Comparison operators}

\fun{long}{gcmp}{GEN x, GEN y} comparison of \kbd{x} with \kbd{y} (returns
the sign ($-1$, 0 or 1) of $\kbd{x}-\kbd{y}$).
\fun{long}{lexcmp}{GEN x, GEN y} comparison of \kbd{x} with \kbd{y} for the
lexicographic ordering.

\fun{long}{gequal}{GEN x, GEN y} returns 1 (true) if \kbd{x} is equal
to~\kbd{y}, 0~otherwise. A priori, this makes sense only if \kbd{x} and
\kbd{y} have the same type. When the types are different, a \kbd{true} result
means that \kbd{x - y} was successfully computed and that
\kbd{gcmp0} found it equal to $0$. In particular
\bprog
  gequal(cgetg(1, t_VEC), gen_0)
@eprog\noindent is true, and the relation is not transitive. E.g.~an empty
\typ{COL} and an empty \typ{VEC} are not equal but are both equal to
\kbd{gen\_0}.

\subsubsec{Comparison with a small integer}

\fun{int}{isexactzero}{GEN x} returns 1 (true) if \kbd{x} is exactly equal
to~0, and 0~(false) otherwise. Note that many PARI functions return \kbd{gen\_0}
when they are aware that the result they return is an exact zero, so it is
almost always faster to test for pointer equality first, and call
\kbd{isexactzero} (or \kbd{gcmp0}) only when the first test fails.

\fun{int}{is_pm1}{GEN x}. This quick and dirty macro assumes that \kbd{x} is
a non-zero \typ{INT}. Under these assumptions, it returns 1 (true) if \kbd{x}
is equal to $-1$ or $1$, and return 0~(false) otherwise.

\fun{int}{is_pm1_lg}{GEN x, long L} as \kbd{is\_pm1} but even lower level:
assumes further that \kbd{lgefint(x) = L}.

\fun{int}{gcmp0}{GEN x} returns 1 (true) if \kbd{x} is equal to~0, 0~(false)
otherwise.

\fun{int}{gcmp1}{GEN x} returns 1 (true) if \kbd{x} is equal to~1, 0~(false)
otherwise.

\fun{int}{gcmp_1}{GEN x} returns 1 (true) if \kbd{x} is equal to~$-1$,
0~(false) otherwise.


\fun{long}{gcmpsg}{long s, GEN x}

\fun{long}{gcmpgs}{GEN x, long s} comparison of \kbd{x} with the
\kbd{long}~\kbd{s}.

\fun{GEN}{gmaxsg}{long s, GEN x}

\fun{GEN}{gmaxgs}{GEN x, long s} returns the largest of \kbd{x} and
the \kbd{long}~\kbd{s} (converted to \kbd{GEN})

\fun{GEN}{gminsg}{long s, GEN x}

\fun{GEN}{gmings}{GEN x, long s} returns the smallest of \kbd{x} and the
\kbd{long}~\kbd{s} (converted to \kbd{GEN})

\fun{long}{gequalsg}{long s, GEN x}

\fun{long}{gequalgs}{GEN x, long s} returns 1 (true) if \kbd{x} is equal to
the \kbd{long}~\kbd{s}, 0~otherwise.

\subsubsec{Other related boolean functions}

\fun{int}{isexactzeroscalar}{GEN g} equivalent to, but faster than,
\bprog
  is_scalar_t(typ(x)) && isexactzero(x)
@eprog

\fun{int}{isinexact}{GEN x} returns 1 (true) if \kbd{x} has an inexact
component, and 0 (false) otherwise.

\fun{int}{isinexactreal}{GEN x} return 1 if \kbd{x} has an inexact
\typ{REAL} component, and 0  otherwise.


\fun{int}{isint}{GEN x, GEN *n} returns 0 (false) if \kbd{x} does not round
to an integer. Otherwise, returns 1 (true) and set \kbd{n} to the rounded
value.

\fun{int}{issmall}{GEN x, long *n} returns 0 (false) if \kbd{x} does not
round to a small integer (suitable for \kbd{itos}). Otherwise, returns 1
(true) and set \kbd{n} to the rounded value.

\fun{long}{iscomplex}{GEN x} returns 1 (true) if \kbd{x} is a complex number
(of component types embeddable into the reals) but is not itself real, 0~if
\kbd{x} is a real (not necessarily of type \typ{REAL}), or raises an error if
\kbd{x} is not embeddable into the complex numbers.

\fun{long}{ismonome}{GEN x} returns 1 (true) if \kbd{x} is a non-zero
monomial in its main variable, 0~otherwise.

\subsubsec{Obsolete}

The following less convenient comparison functions and boolean operators were
used by the historical GP interpreter. They are provided for backward
compatibility only and should not be used:

\fun{GEN}{gle}{GEN x, GEN y}

\fun{GEN}{glt}{GEN x, GEN y}

\fun{GEN}{gge}{GEN x, GEN y}

\fun{GEN}{ggt}{GEN x, GEN y}

\fun{GEN}{geq}{GEN x, GEN y}

\fun{GEN}{gne}{GEN x, GEN y}

\fun{GEN}{gor}{GEN x, GEN y}

\fun{GEN}{gand}{GEN x, GEN y}

\fun{GEN}{gnot}{GEN x, GEN y}

\subsec{Sorting}

\subsubsec{Basic sort}

\fun{GEN}{sort}{GEN x} sorts the vector \kbd{x} in ascending order using a
mergesort algorithm, and \kbd{gcmp} as the undelying comparison routine
(returns the sorted vector). This routine copies all components of $x$, use
\kbd{gen\_sort\_inplace} for a more memory-efficient function.

\fun{GEN}{lexsort}{GEN x}, as \kbd{sort}, using \kbd{lexcmp} instead of
\kbd{gcmp} as the underlying comparison routine.

\fun{GEN}{vecsort}{GEN x, GEN k}, as \kbd{sort}, but sorts the
vector \kbd{x} in ascending \emph{lexicographic} order, according to the
entries of the \typ{VECSMALL} \kbd{k}. For example,  if $\kbd{k} = [2,1,3]$,
sorting will be done with respect to the second component,  and when these
are  equal, with respect to the first,  and when these are equal,  with
respect to the third.

\subsubsec{Indirect sorting}

\fun{GEN}{indexsort}{GEN x} as \kbd{sort}, but only returns the permutation
which, applied to \kbd{x}, would sort the vector. The result is a
\typ{VECSMALL}.

\fun{GEN}{indexlexsort}{GEN x}, as \kbd{indexsort}, using \kbd{lexcmp}
instead of \kbd{gcmp} as the underlying comparison routine.

\fun{GEN}{indexvecsort}{GEN x, GEN k}, as \kbd{vecsort}, but only
returns the permutation that would sort the vector \kbd{x}.

\subsubsec{Generic routines}. The following routines allow to use an
arbitrary comparison function \kbd{int (*cmp)(void* data, GEN x, GEN y)},
such that \kbd{cmp(data,x,y)} returns a negative result if $x
< y$, a positive one if $x > y$ and 0 if $x = y$. The \kbd{data} argument is
there in case your \kbd{cmp} requires additional context.

\fun{GEN}{gen_sort}{GEN x, void *data, int (*cmp)(void *,GEN,GEN)}, as \kbd{sort}.

\fun{GEN}{gen_sort_uniq}{GEN x, void *data, int (*cmp)(void *,GEN,GEN)}, as
\kbd{sort}, removing duplicate entries.

\fun{GEN}{gen_indexsort}{GEN x, void *data, int (*cmp)(void*,GEN,GEN)},
as \kbd{indexsort}.

\fun{GEN}{gen_indexsort_uniq}{GEN x, void *data, int (*cmp)(void*,GEN,GEN)},
as \kbd{indexsort}, removing duplicate entries.

\fun{void}{gen_sort_inplace}{GEN x, void *data, int (*cmp)(void*,GEN,GEN), GEN
*perm} sort \kbd{x} in place, without copying its components. If
\kbd{perm} is non-\kbd{NULL}, it is set to the permutation that would sort
the original \kbd{x}.

\fun{GEN}{sort_factor}{GEN y, void *data, int (*cmp)(void *,GEN,GEN)}:
assuming \kbd{y} is a factorization matrix, sorts its rows in place (no copy
is made) according to the comparison function \kbd{cmp} applied to its first
column.

\fun{GEN}{merge_factor}{GEN fx, GEN fy, void *data, int (*cmp)(void *,GEN,GEN)}
let \kbd{fx} and \kbd{fy} be factorization matrices for $X$ and $Y$
sorted with respect to the comparison function \kbd{cmp} (see
\tet{sort_factor}), returns the factorization of $X * Y$. Zero exponents in
the latter factorization are preserved, e.g. when merging the factorization
of $2$ and $1/2$, the result is $2^0$.

\fun{long}{gen_search}{GEN v, GEN y, long flag, void *data, int
(*cmp)(void*,GEN,GEN)}. Let \kbd{v} be a vector sorted according to
\kbd{cmp(data,a,b)}; look for an index $i$ such that  \kbd{v[$i$]}
is equal to \kbd{y}. \kbd{flag} has the same meaning as in \kbd{setsearch}:
if \kbd{flag} is 0, return $i$ if it exists and 0 otherwise; if \kbd{flag} is
non-zero, return $0$ if $i$ exists and the index where \kbd{y} should be
inserted otherwise.

\fun{long}{tablesearch}{GEN T, GEN x, int (*cmp)(GEN,GEN)} is a faster
implementation for the common case \kbd{gen\_search(T,x,0,cmp,cmp\_nodata)}.

\fun{int}{cmp_nodata}{void *data, GEN x, GEN y}. This function is a hack
used to pass an existing basic comparison function lacking the \kbd{data}
argument, i.e. with prototype \kbd{int (*cmp)(GEN x, GEN y)}. Instead of
\kbd{gen\_sort(x, NULL, cmp)} which may or may not work depending on how your
compiler handles typecasts between incompatible function pointers, one should
use \kbd{gen\_sort(x, (void*)cmp, cmp\_nodata)}.

Here are a few basic comparison functions, to be used with \kbd{cmp\_nodata}:

\fun{int}{cmp_ZV}{GEN x, GEN y} compare two \kbd{ZV}, which we assume have
the same length (lexicographic order).

\fun{int}{cmp_RgX}{GEN x, GEN y} compare two polynomials, which we assume
have the same main variable (lexicographic order). The coefficients are
compared using \kbd{gcmp}.

\fun{int}{cmp_prime_over_p}{GEN x, GEN y} compare two prime ideals, which
we assume divide the same prime number. The comparison is ad hoc but orders
according to increasing residue degrees.

\fun{int}{cmp_prime_ideal}{GEN x, GEN y} compare two prime ideals in the same
\var{nf}. Orders by increasing primes, breaking ties using
\kbd{cmp\_prime\_over\_p}.

Finally a more elaborate comparison function:

\fun{int}{gen_cmp_RgX}{void *data, GEN x, GEN y} compare two polynomials,
ordering first by increasing degree, then according to the coefficient
comparison function:
\bprog
  int (*cmp_coeff)(GEN,GEN) = (int(*)(GEN,GEN)) data;
@eprog

\subsec{Generic unary operators}

\funno{GEN}{gneg[\key{z}]}{GEN x[, GEN z]} yields $-\kbd{x}$.

\fun{GEN}{gneg_i}{GEN x} shallow function yielding $-\kbd{x}$.

\funno{GEN}{gabs[\key{z}]}{GEN x[, GEN z]} yields $|\kbd{x}|$.

\fun{GEN}{gsqr}{GEN x} creates the square of~\kbd{x}.

\fun{GEN}{ginv}{GEN x} creates the inverse of~\kbd{x}.

\subsec{Generic binary operators}

\fun{GEN}{gadd[z]}{GEN x, GEN y[, GEN z]}

\fun{GEN}{gmul[z]}{GEN x, GEN y[, GEN z]}

\fun{GEN}{gdiv[z]}{GEN x, GEN y[, GEN z]}

\fun{GEN}{gaddgs[z]}{GEN x, long s[, GEN z]}

\fun{GEN}{gaddsg[z]}{GEN s, GEN x[, GEN z]}

\fun{GEN}{gsubgs[z]}{GEN x, long s[, GEN z]}

\fun{GEN}{gsubsg[z]}{GEN s, GEN x[, GEN z]}

\fun{GEN}{gmulgs[z]}{GEN x, long s[, GEN z]}

\fun{GEN}{gmulsg[z]}{GEN s, GEN x[, GEN z]}

\fun{GEN}{gdivgs[z]}{GEN x, long s[, GEN z]}

\fun{GEN}{gdivsg[z]}{GEN s, GEN x[, GEN z]}

\subsec{Divisibility, Euclidean division}

\fun{GEN}{gdivexact}{GEN x, GEN y} returns the quotient $\kbd{x} / \kbd{y}$,
assuming $\kbd{y}$ divides $\kbd{x}$.

\fun{int}{gdvd}{GEN x, GEN y}  returns 1 (true) if \kbd{y} divides~\kbd{x},
0~otherwise.

\fun{GEN}{gdiventres}{GEN x, GEN y} creates a 2-component vertical
vector whose components are the true Euclidean quotient and remainder
of \kbd{x} and~\kbd{y}.

\fun{GEN}{gdivent[z]}{GEN x, GEN y[, GEN z]} yields the true Euclidean
quotient of \kbd{x} and the \typ{INT} or \typ{POL}~\kbd{y}.

\fun{GEN}{gdiventsg[z]}{long s, GEN y[, GEN z]}, as \kbd{gdivent}
except that \kbd{x} is a \kbd{long}.

\fun{GEN}{gdiventgs[z]}{GEN x, long s[, GEN z]}, as \kbd{gdivent}
except that \kbd{y} is a \kbd{long}.

\fun{GEN}{gmod[z]}{GEN x, GEN y[, GEN z]} yields the remainder of \kbd{x}
modulo the \typ{INT} or \typ{POL}~\kbd{y}. A \typ{REAL} or \typ{FRAC} \kbd{y}
is also allowed, in which case the remainder is the unique real $r$ such that
$0 \leq r < |\kbd{y}|$ and $\kbd{y} = q\kbd{x} + r$ for some (in fact unique)
integer $q$.

\fun{GEN}{gmodsg[z]}{long s, GEN y[, GEN z]} as \kbd{gmod}, except \kbd{x} is
a \kbd{long}.

\fun{GEN}{gmodgs[z]}{GEN x, long s[, GEN z]} as \kbd{gmod}, except \kbd{y} is
a \kbd{long}.

\fun{GEN}{gdivmod}{GEN x, GEN y, GEN *r} If \kbd{r} is not equal to
\kbd{NULL} or \kbd{ONLY\_REM}, creates the (false) Euclidean quotient of
\kbd{x} and~\kbd{y}, and puts (the address of) the remainder into~\kbd{*r}.
If \kbd{r} is equal to \kbd{NULL}, do not create the remainder, and if
\kbd{r} is equal to \kbd{ONLY\_REM}, create and output only the remainder.
The remainder is created after the quotient and can be disposed of
individually with a \kbd{cgiv(r)}.

\fun{GEN}{poldivrem}{GEN x, GEN y, GEN *r} same as \key{gdivmod} but
specifically for \typ{POL}s~\kbd{x} and~\kbd{y}, not necessarily in the same
variable. Either of \kbd{x} and \kbd{y} may also be scalars (treated as
polynomials of degree $0$)

\fun{GEN}{gdeuc}{GEN x, GEN y} creates the Euclidean quotient of the
\typ{POL}s~\kbd{x} and~\kbd{y}. Either of \kbd{x} and \kbd{y} may also be
scalars (treated as polynomials of degree $0$)

\fun{GEN}{grem}{GEN x, GEN y} creates the Euclidean remainder of the
\typ{POL}~\kbd{x} divided by the \typ{POL}~\kbd{y}.

\fun{GEN}{gdivround}{GEN x, GEN y} if \kbd{x} and \kbd{y} are \typ{INT},
as \kbd{diviiround}. Operate componentwise if \kbd{x} is
a \typ{COL}, \typ{VEC} or \typ{MAT}. Otherwise as \key{gdivent}.

\fun{GEN}{centermod_i}{GEN x, GEN y, GEN y2}, as \kbd{centermodii},
componentwise.

\fun{GEN}{centermod}{GEN x, GEN y}, as \kbd{centermod\_i}, except that
\kbd{y2} is computed (and left on the stack for efficiency).

\fun{GEN}{ginvmod}{GEN x, GEN y} creates the inverse of \kbd{x} modulo \kbd{y}
when it exists. \kbd{y} must be of type \typ{INT} (in which case \kbd{x} is
of type \typ{INT}) or \typ{POL} (in which case \kbd{x} is either a scalar
type or a \typ{POL}).

\subsec{GCD, content and primitive part}

\fun{GEN}{subres}{GEN x, GEN y} creates the resultant of the \typ{POL}s
\kbd{x} and~\kbd{y} computed using the subresultant algorithm. Either of
\kbd{x} and \kbd{y} may also be scalars (treated as polynomials of degree
$0$)

\fun{GEN}{ggcd}{GEN x, GEN y} creates the GCD of \kbd{x} and~\kbd{y}.

\fun{GEN}{glcm}{GEN x, GEN y} creates the LCM of \kbd{x} and~\kbd{y}.

\fun{GEN}{gbezout}{GEN x,GEN y, GEN *u,GEN *v} returns the GCD of \kbd{x}
and~\kbd{y}, and puts (the addresses of) objects $u$ and~$v$ such that
$u\kbd{x}+v\kbd{y}=\gcd(\kbd{x},\kbd{y})$ into \kbd{*u} and~\kbd{*v}.

\fun{GEN}{subresext}{GEN x, GEN y, GEN *U, GEN *V} returns the GCD of \kbd{x}
and~\kbd{y}, and puts (the addresses of) objects $u$ and~$v$ such that
$u\kbd{x}+v\kbd{y}=\text{Res}(\kbd{x},\kbd{y})$ into \kbd{*U} and~\kbd{*V}.

\fun{GEN}{content}{GEN x} creates the GCD of all the components of~\kbd{x}.

\fun{GEN}{primitive_part}{GEN x, GEN *c} sets \kbd{c} to \kbd{content(x)}
and returns the primitive part \kbd{x} / \kbd{c}. A trivial content is set to
\kbd{NULL}.

\fun{GEN}{primpart}{GEN x} as above but the content is lost.
(For efficiency, the content remains on the stack.)

\subsec{GCD, content and primitive part over the rationals}

\fun{long}{Q_pval}{GEN x, GEN p} valuation at the \typ{INT} \kbd{p}
of the \typ{INT} or \typ{FRAC}~\kbd{x}.

\fun{GEN}{Q_abs}{GEN x} absolute value of the \typ{INT} or
\typ{FRAC}~\kbd{x}.

\fun{GEN}{Q_gcd}{GEN x, GEN y} gcd of the \typ{INT} or \typ{FRAC}~\kbd{x}
and~\kbd{y}.
\smallskip

In the following functions, arguments belong to a $M\otimes_\Z\Q$
for some natural $\Z$-module $M$, e.g. multivariate polynomials with integer
coefficients (or vectors/matrices recursively built from such objects), and
an element of $M$ is said to be \emph{integral}.
We are interested in contents, denominators, etc. with respect to this
canonical integral structure; in particular, contents belong to $\Q$,
denominators to $\Z$. For instance the $\Q$-content of $(1/2)xy$ is $(1/2)$,
and its $\Q$-denominator is $2$, whereas \kbd{content} would return $y/2$ and
\kbd{denom}~1.

\fun{GEN}{Q_content}{GEN x} the $\Q$-content of $x$

\fun{GEN}{Q_denom}{GEN x} the $\Q$-denominator of $x$

\fun{GEN}{Q_primitive_part}{GEN x, GEN *c} sets \kbd{c} to the $\Q$-content
of \kbd{x} and returns \kbd{x / c}, which is integral.

\fun{GEN}{Q_primpart}{GEN x} as above but the content is lost. (For
efficiency, the content remains on the stack.)

\fun{GEN}{Q_remove_denom}{GEN x, GEN *ptd} sets \kbd{d} to the
$\Q$-denominator of \kbd{x} and returns \kbd{x * d}, which is integral.

\fun{GEN}{Q_div_to_int}{GEN x, GEN c} returns \kbd{x / c}, assuming $c$
is a rational number (\typ{INT} or \typ{FRAC}) and the result is integral.

\fun{GEN}{Q_mul_to_int}{GEN x, GEN c} returns \kbd{x * c}, assuming $c$
is a rational number (\typ{INT} or \typ{FRAC}) and the result is integral.

\fun{GEN}{Q_muli_to_int}{GEN x, GEN d} returns \kbd{x * c}, assuming $c$
is a \typ{INT} and the result is integral.

\subsec{Complex numbers}

\fun{GEN}{imag}{GEN x} returns a copy of the imaginary part of \kbd{x}.

\fun{GEN}{real}{GEN x} returns a copy of the real part of \kbd{x}. If \kbd{x}
is a \typ{QUAD}, returns the coefficient of $1$ in the ``canonical'' integral
basis $(1,\omega)$.

The last two functions are not suitable for \tet{gerepileupto}:

\fun{GEN}{imag_i}{GEN x} as \kbd{gimag}, returns a pointer to the imaginary
part.
\fun{GEN}{real_i}{GEN x} as \kbd{greal}, returns a pointer to the real part.

\subsec{Generic binary operators}. Let ``\op'' be a binary operation among

\op=\key{add}: addition (\kbd{x + y}).

\op=\key{sub}: subtraction (\kbd{x - y}).

\op=\key{mul}: multiplication (\kbd{x * y}).

\op=\key{div}: division (\kbd{x / y}).

\op=\key{max}: maximum (\kbd{max(x, y)})

\op=\key{min}: minimum (\kbd{min(x, y)})

\noindent The names and prototypes of the functions corresponding
to \op\ are as follows:

\funno{GEN}{g\op[z]}{GEN x, GEN y[, GEN z]}

\funno{GEN}{g\op gs[z]}{GEN x, long s[, GEN z]}

\funno{GEN}{g\op sg[z]}{long s, GEN y[, GEN z]}

\fun{GEN}{gpow}{GEN x, GEN y, long l} creates $\kbd{x}^{\kbd{y}}$. If
\kbd{y} is a \typ{INT}, return \kbd{powgi(x,y)} (the precision \kbd{l} is not
taken into account). Otherwise, the result is $\exp(\kbd{y}*\log(\kbd{x}))$
computed to precision~\kbd{l}.

\fun{GEN}{gpowgs}{GEN x, long n} creates $\kbd{x}^{\kbd{n}}$ using
binary powering.

\fun{GEN}{powgi}{GEN x, GEN y} creates $\kbd{x}^{\kbd{y}}$, where \kbd{y} is a
\typ{INT}, using left-shift binary powering.


\fun{GEN}{gsubst}{GEN x, long v, GEN y} substitutes the object \kbd{y}
into~\kbd{x} for the variable number~\kbd{v}.

\subsec{Miscellaneous functions}

\fun{const char*}{type_name}{long t} given a type number \kbd{t} this routine
returns a string containing its symbolic name. E.g \kbd{type\_name(\typ{INT})}
returns \kbd{"\typ{INT}"}. The return value is read-only.

\section{Further type specific functions}

\subsec{Polynomial and power series}

\fun{GEN}{derivpol}{GEN x} returns the derivative of the \typ{POL} \kbd{x}
with respect to its main variable.

\fun{GEN}{derivser}{GEN x} returns the derivative of the \typ{SER} \kbd{x}
with respect to its main variable.

\fun{GEN}{truecoeff}{GEN x, long n} returns \kbd{polcoeff0(x,n, -1)}, i.e.
the coefficient of the term of degree \kbd{n} in the main variable.

\fun{long}{degree}{GEN x} returns \kbd{poldegree(x, -1)}, the degree of
\kbd{x} with respect to its main variable.

\fun{GEN}{discsr}{GEN x} returns \kbd{poldisc0(x, -1)}, the discriminant
of \kbd{x} with respect to its main variable. Uses the subresultant
algorithm.

\fun{GEN}{subres}{GEN x,GEN y} resultant of \kbd{x} and \kbd{y}, with respect
to the main variable of highest priority. Uses the subresultant algorithm.

\fun{GEN}{resultant2}{GEN x, GEN y} resultant of \kbd{x} and \kbd{y}, with
respect to the main variable of highest priority. Computes the determinant
of Sylvester's matrix.

\fun{GEN}{subresall}{GEN u, GEN v, GEN *sol} returns \kbd{subres(x,y)}. If
\kbd{sol} is not \kbd{NULL}, sets it to the last non-zero remainder
in the polynomial remainder sequence if such a sequence was computed,
and to \kbd{gen\_0} otherwise (e.g. polynomials of degree 0).

\subsec{Vectors and Matrices}
See~\secref{se:clean} and~\secref{se:unclean} for various useful constructors.
Coefficients are accessed and set using \tet{gel}, \tet{gcoeff},
see~\secref{se:accessors}. There are many internal functions to extract or
manipulate subvectors or submatrices but, like the accessors above, none of
them are suitable for \tet{gerepileupto}. Worse, there are no type
verification, nor bound checking, so use at your own risk.

\misctitle{Note.} In the function names below, $i$ stands for \emph{interval}
and $p$ for \emph{permutation}.

\fun{GEN}{shallowcopy}{GEN x} returns a \typ{GEN} whose components are the
components of $x$ (no copy is made). The result may now be used to compute in
place without destroying $x$. This is essentially equivalent to
\bprog
  GEN y = cgetg(lg(x), typ(x));
  for (i = 1; i < lg(x); i++) y[i] = x[i];
  return y;
@eprog\noindent
except that \typ{POLMOD} (resp.~\typ{MAT}) are treated specially since a
shallow copy of the representative (resp.~all columns) is also made.

\fun{GEN}{shallowtrans}{GEN x} returns the transpose of $x$, \emph{without}
copying its components, i.~e.,~it returns a \kbd{GEN} whose components are
(physically) the components of $x$. This is the internal function underlying
\tet{gtrans}.

\fun{GEN}{shallowconcat}{GEN x, GEN y} concatenate $x$ and $y$, \emph{without}
copying components, i.~e.,~it returns a \kbd{GEN} whose components are
(physically) the components of $x$ and $y$.

\fun{GEN}{vconcat}{GEN A, GEN B} concatenate vertically the two \typ{MAT} $A$
and $B$ of compatible dimensions. A \kbd{NULL} pointer is accepted for an
empty matrix. See \tet{shallowconcat}.

\fun{GEN}{row}{GEN A, long i} return $A[i,]$, the $i$-th row of the \typ{MAT}
$A$.

\fun{GEN}{row_i}{GEN A, long i, long j1, long j2} return part of the $i$-th
row of \typ{MAT}~$A$: $A[i,j_1]$, $A[i,j_1+1]\dots,A[i,j_2]$. Assume $j_1
\leq j_2$.

\fun{GEN}{rowcopy}{GEN A, long i} return the row $A[i,]$ of
the~\typ{MAT}~$A$.

\fun{GEN}{rowslice}{GEN A, long i1, long i2} return the \typ{MAT}
formed by the $i_1$-th through $i_2$-th rows of \typ{MAT} $A$. Assume $i_1
\leq i_2$.

\fun{GEN}{rowpermute}{GEN A, GEN p}, $p$ being a \typ{VECSMALL}
representing a list $[p_1,\dots,p_n]$ of rows of \typ{MAT} $A$, returns the
matrix whose rows are $A[p_1,],\dots, A[p_n,]$.

\fun{GEN}{rowslicepermute}{GEN A, GEN p, long x1, long x2}, short for
\bprog
  rowslice(rowpermute(A,p), x1, x2)
@eprog\noindent
(more efficient).

\fun{GEN}{vecslice}{GEN A, long j1, long j2}, return $A[j_1], \dots,
A[j_2]$. If $A$ is a \typ{MAT}, these correspond to \emph{columns} of $A$.
The object returned has the same type as $A$ (\typ{VEC}, \typ{COL} or
\typ{MAT}). Assume $j_1 \leq j_2$.

\fun{GEN}{vecpermute}{GEN A, GEN p} $p$ is a \typ{VECSMALL} representing
a list $[p_1,\dots,p_n]$ of indices. Returns a \kbd{GEN} which has the same
type as $A$ (\typ{VEC}, \typ{COL} or \typ{MAT}), and whose components
are $A[p_1],\dots,A[p_n]$. If $A$ is a \typ{MAT}, these are the
\emph{columns} of $A$.

\fun{GEN}{vecslicepermute}{GEN A, GEN p, long y1, long y2} short for
\bprog
  vecslice(vecpermute(A,p), y1, y2)
@eprog\noindent
(more efficient). Finally, the following convenience routines automate
trivial loops of the form 
\bprog
  for (i = 1; i < lg(a); i++) gel(v,i) = f(gel(a,i), gel(b,i))
@eprog\noindent 
for suitable $f$:

\fun{GEN}{vecinv}{GEN a}. Given a vector $a$,
returns the vector whose $i$-th component is \kbd{ginv}$(a[i])$.

\fun{GEN}{vecmul}{GEN a, GEN b}. Given $a$ and $b$ two vectors of the same
length, returns the vector whose $i$-th component is \kbd{gmul}$(a[i], b[i])$.

\fun{GEN}{vecdiv}{GEN a, GEN b}. Given $a$ and $b$ two vectors of the same
length, returns the vector whose $i$-th component is \kbd{gdiv}$(a[i], b[i])$.

\fun{GEN}{vecpow}{GEN a, GEN n}. Given $n$ a \typ{INT}, returns
the vector whose $i$-th component is $a[i]^n$.

\fun{GEN}{vecmodii}{GEN a, GEN b}. Assuming $a$ and $b$ are two \kbd{ZV}
of the same length, returns the vector whose $i$-th component
is \kbd{modii}$(a[i], b[i])$.

Note that \kbd{vecadd} or \kbd{vecsub} do not exist since \kbd{gadd}
and \kbd{gsub} have the expected behaviour. On the other hand, 
\kbd{ginv} does not accept vector types, hence \kbd{vecinv}.

\subsec{Low-level vectors and columns functions}

Theses functions handle \typ{VEC} as an abstract container type of
\kbd{GEN}s. No specific meaning is attached to the content. They accept both
\typ{VEC} and \typ{COL} as input, but \kbd{col} functions always return
\typ{COL} and \kbd{vec} functions always return \typ{VEC}.

\misctitle{Note.} All the functions below are shallow.

\fun{GEN}{const_col}{long n, long c} returns a \typ{COL} of \kbd{n} components
equal to \kbd{c}.

\fun{GEN}{const_vec}{long n, long c} returns a \typ{VEC} of \kbd{n} components
equal to \kbd{c}.

\fun{int}{vec_isconst}{GEN v} Returns 1 if all the components of \kbd{v} are
equal, else returns 0.

\fun{int}{vec_is1to1}{GEN v}  Returns 1 if the components of \kbd{v} are
pair-wise distinct, i.e. if $i\mapsto v[i]$ is a 1-to-1 mapping, else returns
0.

\fun{GEN}{vec_shorten}{GEN v, long n} shortens the vector \kbd{v} to \kbd{n}
components.

\fun{GEN}{vec_lengthen}{GEN v, long n} lengthens the vector \kbd{v}
to \kbd{n} components. The extra components are not initialized.

\subsec{Function to handle \typ{VECSMALL}}

Theses functions handle \typ{VECSMALL} as an abstract container type
of small signed integers. No specific meaning is attached to the content.

\fun{GEN}{const_vecsmall}{long n, long c} returns a \typ{VECSMALL}
of \kbd{n} components equal to \kbd{c}.

\fun{GEN}{vec_to_vecsmall}{GEN z} identical to \kbd{ZV\_to\_zv(z)}.

\fun{GEN}{vecsmall_to_vec}{GEN z} identical to \kbd{zv\_to\_ZV(z)}.

\fun{GEN}{vecsmall_to_col}{GEN z} identical to \kbd{zv\_to\_ZC(z)}.

\fun{GEN}{vecsmall_copy}{GEN x} makes a copy of \kbd{x} on the stack.

\fun{GEN}{vecsmall_shorten}{GEN v, long n} shortens the \typ{VECSMALL} \kbd{v}
to \kbd{n} components.

\fun{GEN}{vecsmall_lengthen}{GEN v, long n} lengthens the \typ{VECSMALL}
\kbd{v} to \kbd{n} components. The extra components are not initialized.

\fun{GEN}{vecsmall_indexsort}{GEN x} performs an indirect sort of the
components of the \typ{VECSMALL} \kbd{x} and return a permutation stored in a
\typ{VECSMALL}.

\fun{void}{vecsmall_sort}{GEN v} sorts the \typ{VECSMALL} \kbd{v} in place.

\fun{long}{vecsmall_isin}{GEN v, long x} returns the first index $i$
such that \kbd{v[$i$]} is equal to \kbd{x}. Naive search in linear time, does
not assume that \kbd{v} is sorted.

\fun{GEN}{vecsmall_uniq}{GEN v} given a sorted \typ{VECSMALL} \kbd{v}, return
the vector of unique occurrences.

\fun{int}{vecsmall_lexcmp}{GEN x, GEN y} compares two \typ{VECSMALL} lexically

\fun{int}{vecsmall_prefixcmp}{GEN x, GEN y} truncate the longest \typ{VECSMALL}
to the length of the shortest and compares them lexicographically.

\fun{GEN}{vecsmall_prepend}{GEN V, long s} prepend \kbd{s} to the \typ{VECSMALL} \kbd{V}.

\fun{GEN}{vecsmall_append}{GEN V, long s} append \kbd{s} to the \typ{VECSMALL} \kbd{V}.

\fun{GEN}{vecsmall_concat}{GEN u, GEN v} concat the \typ{VECSMALL} \kbd{u} and \kbd{v}.

\fun{long}{vecsmall_coincidence}{GEN u, GEN v} returns the numbers of indices where \kbd{u} and \kbd{v} agree.

\fun{long}{vecsmall_pack}{GEN v, long base, long mod} handles the
\typ{VECSMALL} \kbd{v} as the digit of a number in base \kbd{base} and return
this number modulo \kbd{mod}. This can be used as an hash function.

\subsec{Functions to handle bits-vectors}
Theses functions manipulate vectors of bits (stored in \typ{VECSMALL}).
Bits are numbered from 0.

\fun{GEN}{bitvec_alloc}{long n} allocates a bits-vector suitable for \kbd{n}
bits.

\fun{GEN}{bitvec_shorten}{GEN bitvec, long n} shortens a bits-vector
\kbd{bitvec} to \kbd{n} bits.

\fun{long}{bitvec_test}{GEN bitvec, long b} returns the bit of index \kbd{b} of
\kbd{bitvec}.

\fun{void}{bitvec_set}{GEN bitvec, long b} (in place) sets the bit of index
\kbd{b} of \kbd{bitvec}.

\fun{void}{bitvec_clear}{GEN bitvec, long b} (in place) clears the bit of index \kbd{b} of \kbd{bitvec}.

\subsec{Functions to handle vectors of \typ{VECSMALL}}
Theses functions manipulate vectors of \typ{VECSMALL} (vecvecsmall).

\fun{GEN}{vecvecsmall_sort}{GEN x} sorts lexicographically the components of
the vector \kbd{x}.

\fun{GEN}{vecvecsmall_indexsort}{GEN x} performs an indirect lexicographic sorting of the components of the vector \kbd{x} and return a permutation stored in a \typ{VECSMALL}.

\fun{long}{vecvecsmall_search}{GEN x, GEN y, long flag} \kbd{x} being a sorted
vecvecsmall and \kbd{y} a \typ{VECSMALL}, search \kbd{y} inside \kbd{x}. \kbd{fla} has the same meaning as for \kbd{setsearch}.

\subsec{Functions to handle \typ{FFELT}}
These functions define the public interface of the \typ{FFELT} type to use in
generic functions.  However, in specific functions, it is better to use the
functions class \kbd{FpXQ} and/or \kbd{Flxq} as appropriate.

\fun{GEN}{FF_p}{GEN a} returns the characteristic of the definition field of the
\typ{FFELT} element \kbd{a}.

\fun{GEN}{FF_to_FpXQ}{GEN a} converts the \typ{FFELT} \kbd{a} to a polynomial
$P$ with \typ{INT} coefficients such that $a=P(g)$ where $g$ is the generator
of the finite field returned by \kbd{ffgen}, in the variable used to display
$g$.

\fun{GEN}{FF_1}{GEN a} returns the unity in the definition field of the
\typ{FFELT} element \kbd{a}.

\fun{GEN}{FF_zero}{GEN a} returns the zero element of the definition field of
the \typ{FFELT} element \kbd{a}.

\fun{int}{FF_cmp0}{GEN a}, \fun{int}{FF_cmp1}{GEN a}, \fun{int}{FF_cmp_1}{GEN
a} returns $1$ if the \typ{FFELT} \kbd{a} is equal to $0$ (resp. $1$, resp.
$-1$) else $0$.

\fun{int}{FF_equal}{GEN a, GEN b} return $1$ if the \typ{FFELT} \kbd{a} and
\kbd{b} have the same definition field and are equal, else $0$.

\fun{int}{FF_samefield}{GEN a, GEN b} return $1$ if the \typ{FFELT} \kbd{a} and
\kbd{b} have the same definition field, else $0$.

\fun{GEN}{FF_add}{GEN a, GEN b} returns $a+b$ where \kbd{a} and \kbd{b} are
\typ{FFELT} having the same definition field.

\fun{GEN}{FF_mul}{GEN a, GEN b} returns $a\*b$ where \kbd{a} and \kbd{b} are
\typ{FFELT} having the same definition field.

\fun{GEN}{FF_div}{GEN a, GEN b} returns $a/b$ where \kbd{a} and \kbd{b} are
\typ{FFELT} having the same definition field.

\fun{GEN}{FF_neg}{GEN a} returns $-a$ where \kbd{a} is a \typ{FFELT}.

\fun{GEN}{FF_neg_i}{GEN a} shallow function returning $-a$ where \kbd{a} is a
\typ{FFELT}.

\fun{GEN}{FF_inv}{GEN a} returns $a^{-1}$ where \kbd{a} is a \typ{FFELT}.

\fun{GEN}{FF_sqr}{GEN a} returns $a^2$ where \kbd{a} is a \typ{FFELT}.

\fun{GEN}{FF_mul2n}{GEN a, long n} returns $a\*2^n$ where \kbd{a} is a \typ{FFELT}.

\fun{GEN}{FF_pow}{GEN x, GEN n} returns $a^n$ where \kbd{a} is a \typ{FFELT}
and\kbd{n} is a \typ{INT}.

\fun{GEN}{FF_Z_Z_muldiv}{GEN a, GEN x, GEN y} returns $a\*y/z$, where \kbd{a}
is a \typ{FFELT}, and \kbd{x} and \kbd{y} are \typ{INT}, the computation being
performed in the definition field of \kbd{a}.

\fun{GEN}{FF_Z_add}{GEN a, GEN x} returns $a+x$, where \kbd{a} is a
\typ{FFELT}, and \kbd{x} is a \typ{INT}, the computation being
performed in the definition field of \kbd{a}.

\fun{GEN}{FF_Z_mul}{GEN a, GEN b} returns $a\*x$, where \kbd{a} is a
\typ{FFELT}, and \kbd{x} is a \typ{INT}, the computation being
performed in the definition field of \kbd{a}.

\fun{GEN}{Z_FF_div}{GEN x, GEN a} return $x/a$ where \kbd{a} is a
\typ{FFELT}, and \kbd{x} is a \typ{INT}, the computation being
performed in the definition field of \kbd{a}.

\fun{GEN}{FF_norm}{GEN a} returns the norm of the \typ{FFELT} \kbd{a} with
respect to its definition field.

\fun{GEN}{FF_trace}{GEN a} returns the trace of the \typ{FFELT} \kbd{a} with
respect to its definition field.

\fun{GEN}{FF_charpoly}{GEN a} returns the characteristic polynomial) of the
\typ{FFELT} \kbd{a} with respect to its definition field.

\fun{GEN}{FF_minpoly}{GEN a} returns the minimal polynomial of
the \typ{FFELT} \kbd{a}.

\fun{GEN}{FF_sqrt}{GEN a} returns an \typ{FFELT} $b$ such that $a=b^2$ if
it exist, where \kbd{a} is a \typ{FFELT}.

\fun{GEN}{FF_sqrtn}{GEN a, GEN n, GEN *zetan} returns an \kbd{n}-th root of
$\kbd{a}$ if it exist. If \kbd{zn} is non-\kbd{NULL} set it to a primitive
\kbd{n}-th root of the unity.

\fun{GEN}{FF_log}{GEN a, GEN g, GEN o} the \typ{FFELT} \kbd{g} being a
generator fo the definition field of the \typ{FFELT} \kbd{a}, returns a
\typ{INT} $e$ such that $a^e=g$.  If $e$ does not exists, the result is
currently undefined. If \kbd{o} is not \kbd{NULL} it is assumed to be a
factorization of the multiplicative order of \kbd{g} (as set by
\tet{FF_primroot})

\fun{GEN}{FF_order}{GEN a, GEN o} returns the order of the \typ{FFELT} \kbd{a}.
If \kbd{o} is non-\kbd{NULL}, it is assumed that \kbd{o} is a multiple of the
order of \kbd{a}.

\fun{GEN}{FF_primroot}{GEN a, GEN *o} returns a generator of the
multiplicative group of the definition field of the \typ{FFELT} \kbd{a}.
If \kbd{o} is not \kbd{NULL}, set it to the factorization of the order
of the primitive root (to speed up \tet{FF_log}).

\fun{GEN}{FFX_factor}{GEN f, GEN a} returns the factorisation of the univariate
polynomial \kbd{f} over the definition field of the \typ{FFELT} \kbd{a}. The
coefficients of \kbd{f} must be of type \typ{INT}, \typ{INTMOD} or \typ{FFELT}
and compatible with \kbd{a}.

\section{Handling user and temp variables}
Low-level implementation of user / temporary variables is liable to change. We
describe it nevertheless for completeness. Currently variables are
implemented by a single array of values divided in 3 zones: 0--\kbd{nvar}
(user variables), \kbd{max\_avail}--\kbd{MAXVARN} (temporary variables),
and \kbd{nvar+1}--\kbd{max\_avail-1} (pool of free variable numbers).

\subsec{Low-level}

\fun{void}{pari_var_init}{}: a small part of \kbd{pari\_init}. Resets
variable counters \kbd{nvar} and \kbd{max\_avail}, notwithstanding existing
variables! In effect, this even deletes \kbd{x}. Don't use it.

\fun{long}{pari_var_next}{}: returns \kbd{nvar}, the number of the next user
variable we can create.

\fun{long}{pari_var_next_temp}{} returns \kbd{max\_avail}, the number of the
next temp variable we can create.

\fun{void}{pari_var_create}{entree *ep} low-level initialization of an
\kbd{EpVAR}.

\subsec{User variables}

\fun{long}{fetch_user_var}{char *s} returns a user variable whose name
is \kbd{s}, creating it is needed (and using an existing variable otherwise).
Returns its variable number.

\fun{entree*}{fetch_named_var}{char *s} as \kbd{fetch\_user\_var}, but
returns an \kbd{entree*} suitable for inclusion in the interpreter hashlists
of symbols, not a variable number. \kbd{fetch\_user\_var} is a trivial
wrapper.

\fun{GEN}{fetch_var_value}{long v} returns a shallow copy of the
current value of the variable numbered $v$. Return \kbd{NULL} for a temporary
variable.

\fun{void}{delete_named_var}{entree *ep} delete variable created by
\kbd{fetch\_named\_var}, which must be the last one created. Don't use this:
if a variable is to be deleted, it should be a temp.

\fun{entree*}{is_entry}{const char *s} returns the \kbd{entree*} associated
to an identifier \kbd{s} (variable or function), from the interpreter
hashtables. Return \kbd{NULL} is the identifier is unknown.

\subsec{Temporary variables}

\fun{long}{fetch_var}{void} returns the number of a new temporary variable
(decreasing \kbd{max\_avail}).

\fun{long}{delete_var}{void} delete latest temp variable created and return
the number of previous one.

\fun{void}{name_var}{long n, char *s} rename temporary variable number
\kbd{n} to \kbd{s}; mostly useful for nicer printout. Error when trying to
rename a user variable: use \kbd{fetch\_named\_var} to get a user variable of
the right name in the first place.

\section{General Number Fields}

\subsec{Number field types}

None of the following routines thoroughly check their intput: they 
distinguish between \emph{bona fide} structures as output by PARI routines,
but designing perverse data will easily fool them. To give an example, a
square matrix will be interpreted as an ideal even though the $\Z$-module
generated by its columns may not be an $O_K$-module (i.e. the expensive
\kbd{nfisideal} routine will \emph{not} be called).

\fun{long}{nftyp}{GEN x}. Returns the type of number field structure stored in
\kbd{x}, \tet{typ_NF}, \tet{typ_BNF}, or \tet{typ_BNR}. Other answers
are possible, meaning \kbd{x} is not a number field structure.

\fun{GEN}{get_nf}{GEN x, long *t}. Extract an \var{nf} structure from 
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{get_bnf}{GEN x, long *t}. Extract a \kbd{bnf} structure from 
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{checknf}{GEN x} if an \var{nf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_nf} is often more flexible.

\fun{GEN}{checkbnf}{GEN x} if an \var{bnf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_bnf} is often more flexible.

\fun{void}{checkbnr}{GEN bnr} Raise an exception if the argument
is not a \var{bnr} structure.

\fun{void}{checkbnrgen}{GEN bnr} Raise an exception if the argument is not a
\var{bnr} structure, complete with explicit generators for the ray class group.

\fun{void}{checkrnf}{GEN rnf} Raise an exception if the argument is not an
\var{rnf} structure.

\fun{void}{checkbid}{GEN bid} Raise an exception if the argument is not a
\var{bid} structure.

\fun{GEN}{checkgal}{GEN x} if a \var{galoisinit} structure can be extracted
from \kbd{x}, return it; otherwise raise an exception.

\fun{void}{checksqmat}{GEN x, long N} check whether \kbd{x} is a square matrix
of dimension \kbd{N}. May be used to check for ideals if \kbd{N} is the field
degree.

\fun{void}{checkprimeid}{GEN bid} Rase an exception if the argument is not a
prime ideal structure.

\fun{void}{checkmodpr}{GEN modpr} Rase an exception if the argument is not a
 prime ideal structure.

\fun{GEN}{checknfelt_mod}{GEN nf, GEN x, char *s} Given an \var{nf} structure
\kbd{nf} and a \typ{POLMOD} \kbd{x}, return the associated polynomial
representative (shallow) if \kbd{x} and \kbd{nf} are compatible. Raise an
eception otherwise.

\fun{long}{idealtyp}{GEN *ideal, GEN *arch} The input is \kbd{ideal}, a pointer
to an ideal or idele, which is usually modified, \kbd{arch} being set as a
side-effect. Returns the type of the underlying ideal among
\tet{id_PRINCIPAL} (a number field element), \tet{id_PRIME} (a prime ideal)
\tet{id_MAT} (an ideal in matrix form).

If \kbd{ideal} pointed to an ideal, set \kbd{arch} to \kbd{NULL}, and
possibly simplify \kbd{ideal} (for instance an $N\times 1$ matrix is replaced
by an elment in \typ{COL} form). If it pointed to an idele, replace
\kbd{ideal} by the underlying ideal and set \kbd{arch} to the archimedean
component.

\subsec{Increasing accuracy}

\fun{GEN}{nfnewprec}{GEN x, long prec}. Raise an exception if \kbd{x}
is not a number field structure (\var{nf}, \var{bnf} or \var{bnr}).
Otherwise, sets its accuracy to \kbd{prec} and return the new structure. 
This is mostly useful with \kbd{prec} larger than the accuracy to 
which \kbd{x} was computed, but it is also possible to decrease the accuracy
of \kbd{x} (truncating relevant components, which may speed up later
computations). This routine may modify the original \kbd{x} (see below).

This routine is straighforward for \var{nf} structures, but for the
other ones, it requires all principal ideals corresponding to the \var{bnf}
relations in algebraic form (they are originally only available via floating
point approximations). This in turn requires many calls to
\kbd{bnfisprincipal}, which is often slow, and may fail if the initial
accuracy was too low. In this case, the routine will not actually fail but
recomputes a \var{bnf} from scratch!

Since this process may be very expensive, the corresponding data is cached
(as a \emph{clone}) in the \emph{original} \kbd{x} so that later precision
increases become very fast. In particular, the copy returned by
\kbd{nfnewprec} also contains this additional data.

\fun{GEN}{bnfnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts 
a \var{bnf} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{bnrnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts a
\var{bnr} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{nfnewprec_shallow}{GEN nf, long prec}

\fun{GEN}{bnfnewprec_shallow}{GEN bnf, long prec}

\fun{GEN}{bnrnewprec_shallow}{GEN bnr, long prec} Shallow functions
underlying the above, except that the first argument must now have the
corresponding number field type. I.e. one cannot call
\kbd{nfnewprec\_shallow(nf, prec)} if \kbd{nf} is actually a \var{bnf}.

\section{Miscellaneous routines}

\subsec{Linear algebra}

\fun{GEN}{RgV_dotproduct}{GEN x,GEN y} returns the scala product of $x$ and $y$

\fun{GEN}{ZV_dotproduct}{GEN x,GEN y} as \kbd{RgV\_dotproduct} assuming $x$ and $y$
have \typ{INT} entries.

\fun{GEN}{RgV_dotsquare}{GEN x} returns the scala product of $x$ with itself.

\fun{GEN}{ZV_dotsquare}{GEN x} as \kbd{RgV\_dotsquare} assuming $x$
has \typ{INT} entries.

\fun{GEN}{gram_matrix}{GEN v} returns the \idx{Gram matrix} associated to the
vector of

\fun{GEN}{RgM_Rg_add}{GEN x, GEN y} assuming $x$ is a square matrix
and $y$ a scalar, returns the square matrix $x + y*\text{Id}$.

\fun{GEN}{RgM_Rg_add_shallow}{GEN x, GEN y} as \kbd{RgM\_Rg\_add} with much
fewer copies.

The following routines check whether matrices or vectors have a special
shape, using \kbd{gcmp1} and \kbd{gcmp0} to test components. (This may make a
difference when components are inexact.)

\fun{long}{RgV_isscalar}{GEN x} return 1 if $x$ all the entries of $x$ are $0$
except possibly the first one. The name comes from vectors expressed on a
standard polynomial basis $1,T,\dots, T^{n-1}$, or on \kbd{nf.zk} (whose
first element is $1$).

\fun{long}{isnfscalar}{GEN x} returns $1$ if $x$ is a number field element
in \typ{COL} form, which is a scalar (such that \kbd{RgV\_isscalar(x)}
is $1$) and $0$ otherwise.

\fun{long}{RgM_isscalar}{GEN x, GEN s} return 1 if $x$ is the scalar matrix
equalt to $s$ times the identity, and 0 otherwise. If $s$ is \kbd{NULL}, test
whether $x$ is an arbitrary scalar matrix.

\fun{long}{RgM_isidentity}{GEN x} return 1 is the \typ{MAT} $x$ is the
identity matrix, and 0 otherwise.

\fun{long}{RgV_isin}{GEN v, GEN x} return the first index $i$ such that
$v[i] = x$ if it exists, and $0$ otherwise. Naive search in linear time, does
not assume that \kbd{v} is sorted.

\subsec{Transcendental functions}

The following two functions are only useful when interacting with \kbd{gp},
to manipulate its internal default precision (expressed as a number of
decimal digits, not in words as used everywhere else):

\fun{long}{getrealprecision}{void} returns \kbd{realprecision}.

\fun{long}{setrealprecision}{long n, long *prec} sets the new
\kbd{realprecision} to $n$, which is returned. As a side effect, set
\kbd{prec} to the corresponding number of words \kbd{ndec2prec(n)}.

In the following routines, $x$ is assumed to be a \typ{REAL} and the result
is a \typ{REAL} with the largest accuracy which can be deduced from the input:
The naming scheme is inconsistant here, since we somethimes use the
prefix\kbd{mp} even though \typ{INT} inputs are forbidden:

\fun{GEN}{sqrtr}{GEN x} returns the square root of $x$.

\fun{GEN}{sqrtnr}{GEN x, long n} returns the $n$-th root of $x$, assuming
$n\geq 1$.


\fun{GEN}{mpcos}{GEN x} returns $\cos(x)$.

\fun{GEN}{mpsin}{GEN x} returns $\sin(x)$.

\fun{GEN}{mplog}{GEN x} returns $\log(x)$. We must have $x > 0$ since the
result must be a \typ{REAL}. Use \kbd{glog} for the general case, where
you want such computations as $\log -1 = i$.

\fun{GEN}{mpexp}{GEN x} returns $\exp(x)$.

\fun{GEN}{mpexp1}{GEN x} returns $\exp(x)-1$, but is more accurate than
\kbd{subrs(mpexp(x), 1)}, which suffers from catastrophic cancellation if
$|x|$ is very small.
Two variants of sin and cos:

\fun{void}{mpsincos}{GEN x, GEN *s, GEN *c} sets $s$ and $c$ to
$\sin(x)$ and $\cos(x)$ respectively, where $x$ is a \typ{REAL}

\fun{void}{gsincos}{GEN x, GEN *s, GEN *c, long prec} general case.

\fun{GEN}{szeta}{long s, long prec} returns the value of Riemann's zeta
function at the (possibly negative) integer $s\neq 1$, in relative accuracy \kbd{prec}.


\vfill\eject
